{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 "},"page/1011.html":{"url":"page/1011.html","title":"简介","keywords":"","body":"简介 什么是JSP JSP是Java Server Page的缩写，是由Sun公司倡导，许多公司参与，于1999年推出的一种Web服务设计标准。 "},"page/1012.html":{"url":"page/1012.html","title":"环境","keywords":"","body":"环境 "},"page/1014.html":{"url":"page/1014.html","title":"原理","keywords":"","body":"原理 环境简介 所谓B/S模式(Browser/Server浏览器/服务器模式)，是指需要获取信息的用户使用浏览器向服务器发出请求，服务器对此做出响应，将有关信息发送给用户的浏览器。 在B/S模式中，服务器上必须有所谓的Web应用程序，服务器通过运行这些Web应用程序来响应用户的请求。因此，基于B/S模式的网络程序的核心就是设计服务器端的Web应用程序。 一个服务器上可以有很多基于JSP的Web应用程序，以满足各种用户的需求。这些Web应用程序必须有一个软件来统一管理和运行，这样的软件被称作JSP引擎或JSP容器，而安装JSP引擎的计算机被称作一个支持JSP的Web服务器。 Tomcat是一个免费的开源JSP引擎，将安装了Tomcat的计算机称作一个Tomcat服务器。 JSP运行原理 当服务器上的一个JSP页面被第一次请求执行时，服务器上的JSP引擎首先将JSP页面文件转译成一个java文件，并编译这个java文件生成字节码文件，然后执行字节码文件响应客户的请求。 把JSP页面中普通的HTML标记符号交给客户的浏览器执行显示。 负责处理JSP标记,并将有关的处理结果发送到客户的浏览器。 执行和%>之间的Java程序片（JSP页面中的动态部分），并把执行结果交给客户的浏览器显示。 当多个客户请求一个JSP页面时，Tomcat服务器为每个客户启动一个线程，该线程负责执行常驻内存的字节码文件来响应相应客户的请求。这些线程由Tomcat服务器来管理，将CPU的使用权在各个线程之间快速切换，以保证每个线程都有机会执行字节码文件 Tomcat目录结构及其功能 bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。 conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。 lib：库文件。tomcat运行时需要的jar包所在的目录 logs：日志 temp：临时产生的文件，即缓存 webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问 work：编译以后的class文件。 JSP与Java Servlet的关系 Java Servlet是Java 语言的一部分，提供了用于服务器编程的API。Java Servlet就是编写在服务器端创建对象的Java类，习惯上称之为Servlet类，Servlet类的对象习惯上称之为一个servlet。 JSP技术就是以Java Servlet为基础，提供了Java Servlet的几乎所有好处，当客户请求一个JSP页面时，Tomcat服务器自动生成Java文件（如first1$jsp.java）、编译Java文件，并用编译得到的字节码文件在服务器端创建一个servlet。但是JSP技术不是Java Servlet技术的全部，它只是Java Servlet技术的一个成功应用。 对于某些Web应用，就可能需要JSP+Javabean+servlet来完成，即需要服务器再创建一些servlet对象，配合JSP页面来完成整个Web应用程序的工作。 小结 JSP技术不仅是开发Web应用的先进技术，而且是进一步学习相关技术的基础。 JSP引擎是支持JSP程序的Web容器，负责运行JSP，并将有关结果发送到客户端。目前流行的JSP引擎之一是Tomcat。 安装Tomcat服务器，首先要安装JDK，并需要设置Java_home环境变量。 JSP页面必须保存在Web服务目录中。Tomcat服务器的webapps下的目录都可以作为Web服务目录。如果想让webapps以外的其他的目录作为Web服务目录，必须要修改Tomcat服务器下conf文件夹中的server.xml文件，并重新启动Tomcat服务器。 当服务器上的一个JSP页面被第一次请求执行时，服务器上的JSP引擎首先将JSP页面文件转译成一个Java文件，再将这个Java文件编译生成字节码文件，然后通过执行字节码文件响应客户的请求。 当多个客户请求一个JSP页面时，Tomcat服务器为每个客户启动一个线程，该线程负责执行常驻内存的字节码文件来响应相应客户的请求。这些线程由Tomcat服务器来管理，将CPU的使用权在各个线程之间快速切换，以保证每个线程都有机会执行字节码文件。 "},"page/1015.html":{"url":"page/1015.html","title":"配置","keywords":"","body":"环境配置 配置java环境变量 https://zlogs.net/learn-java/page/1013.html 配置tomcat环境变量 下载 http://tomcat.apache.org/ Linux 1.解压 解压之后的文件放在一个目录假设为/usr/local/apache-tomcat-9.0.34目录，注意文件夹apache-tomcat-9.0.34里面就是bin、conf、lib那些，注意路径里面不要有中文字符和空格。 2.配置环境变量 给所有用户配置Tomcat环境 以root用户登录 sudo -i 修改配置文件系统级别变量 vim /etc/profile 按下insert键，然后移动到最后一行，添加 #configuration tomcat development enviroument CATALINA_HOME=/media/zander/file/deepin/dev/tomcat/apache-tomcat-9.0.34 export PATH={% math_inline %}CATALINA_HOME/bin:{% endmath_inline %}PATH 然后按下esc键，输入:,输入wq退出 重新加载系统配置 source /etc/profile 给当前用户配置Tomcat环境 同理修改用户配置 vim ~/.bash_profile （注意修改上面命令只对bash作为shell有效，如果是zsh,则为vim ~/.zshrc） 3.启动与关闭 启动，输入 startup.sh 或者{% math_inline %}CATALINA_HOME/bin/startup.sh 如果能看到对应启动信息，则说明Tomcat环境变量配置成功 Using CATALINA_BASE: /media/zander/file/deepin/dev/tomcat/apache-tomcat-9.0.34 Using CATALINA_HOME: /media/zander/file/deepin/dev/tomcat/apache-tomcat-9.0.34 Using CATALINA_TMPDIR: /media/zander/file/deepin/dev/tomcat/apache-tomcat-9.0.34/temp Using JRE_HOME: /media/zander/file/deepin/dev/java/jdk/jdk1.8.0_241 Using CLASSPATH: /media/zander/file/deepin/dev/tomcat/apache-tomcat-9.0.34/bin/bootstrap.jar:/media/zander/file/deepin/dev/tomcat/apache-tomcat-9.0.34/bin/tomcat-juli.jar Tomcat started.#出现这样类似的表示成功，若提示无此命令则配置错误 关闭输入shutdown.sh 4.注意 1.启动后代开浏览器查看http://127.0.0.1:8080查看是否有tomcat默认页面， 如果8080端口被占用可能无法启动可使用sudo netstat -ntulp | grep 8080查看是否被占用，如果被占用，且必要可以修改tomcat的端口在安装目录/conf/server.xml的大概70行左右 改掉下面其他端口，可使用sudo netstat -ntulp | grep 其他端口查看将要替换的端口是否是空闲的 2.如果是linux桌面环境，系统变量配置，用户变量未配置，可能会出现直接进入目录点击startup.sh提示启动成功，或者用自动脚本进入启动提示成功，但是8080端口没有数据，查看当前用户使用的bash的是否添加环境变量 配置Vscode 1.安装插件 https://marketplace.visualstudio.com/items?itemName=adashen.vscode-tomcat 2.停掉已有tomcat服务 如果已经启动服务，执行自己的tomcat安装目录/bin/shutdown.sh或者{% endmath_inline %}CATALINA_HOME/bin/shutdown.sh，如果配置环境变量的话，直接shutdown.sh也可以 不然可能会报错正在摧毁协议处理器之类的。 3.新建项目 手动打开或者新建一个项目，新建一个test.jsp,里面填入下列内容 4.打包项目 在vscode里按ctrl+p组合键，输入>tomcat:generate并回车，生成.war文件 5.添加server 点击Tomcat servers添加符号，选择安装目录，点击打开 6.启动server 选择.war文件，右击启动 7. 打开网页访问测试 右击点开在浏览器打开 如果没有index.jsp的话会提示未找到 在后面输入我们创建的1.jsp即可访问 参考 https://www.runoob.com/jsp/jsp-setup.html https://www.jianshu.com/p/1355b54a5801 "},"page/1036.html":{"url":"page/1036.html","title":"目录","keywords":"","body":"目录 设置Web服务目录 简介 必须将编写好的JSP页面文件保存到Tomcat服务器的某个Web服务目录中，只有这样，远程的用户才可以通过浏览器访问该Tomcat服务器上的JSP页面。 人们常说的一个网站，实际上就是一个Web服务目录。 根目录 如果Tomcat服务器的安装目录是D:\\apache-tomcat-8.0.3，那么Tomcat的Web服务目录的根目录是D:\\apache-tomcat-8.0.3\\webapps\\Root 可以在浏览器输入Tomcat服务器的IP地址（或域名）、端口号和JSP页面的名字即可（必须省略Web根目录的名字） 将下面内容保存为helloworld.jsp,放在安装目录/webapps/ROOT 在开启tomcat服务的情况下,访问http://127.0.0.1:8080/helloworld.jsp即可看到内容。 webapps下的Web服务目录 Tomcat服务器安装目录webapps下的任何一个子目录都可以作为一个Web服务目录。比如在webapps下新建子目录ch1，那么ch1就成为一个Web服务目录。 将JSP页面文件保存到webapps下的Web服务目录中，那么应当在浏览器器的地址栏中输入Tomcat服务器的IP地址（或域名）、端口号、Web服务目录和JSP页面的名字。 将下面内容保存为helloworld.jsp,放在安装目录/webapps/ch1 在开启tomcat服务的情况下,访问http://127.0.0.1:8080/ch1/helloworld.jsp即可看到内容。 自定义服务目录（新建Web服务目录） 可以将Tomcat服务器所在计算机的某个目录（非webapps下的子目录）设置成一个Web服务目录，并为该Web服务目录指定虚拟目录，即隐藏Web服务目录的实际位置，用户只能通过虚拟目录访问Web服务目录中的JSP页面。 打开conf文件夹中的主配置文件server.xml，在的前面加入： 将下面内容保存为helloworld.jsp,保存到任意目录如D:\\MyBook\\zhang以及C:\\wang中， 目的：让用户分别使用apple和cloud虚拟目录访问此Web服务目录 用记事本打开conf文件夹中的主配置文件server.xml，在的前面加入 保存并重新启动 tomcat服务器 访问http://127.0.0.1:8080/apple/helloworld.jsp即可看到内容 相对目录（服务目录内的） Web服务目录的下的目录称为该Web服务目录下的相对Web服务目录。 比如，在Web服务目录D:\\MyBook\\zhang下再建立一个子目录image，将example.jsp文件保存到image中。 按照上一步自定义web服务目录，将D:\\MyBook\\zhang设置为自定义web服务目录，虚拟目录为apple 那么可以在浏览器的地址栏中输入http://127.0.0.1:8080/apple/image/example.jsp即可看到内容 Tag文件的存储目录 如果某个Web服务目录下的JSP页面准备调用一个Tag文件，那么我们必须在该Web服务目录下，建立如下的目录结构： Web服务目录\\WEB-INF\\tags ch3\\WEB-INF\\tags 其中的WEB-INF和tags都是固定的目录名称， 而tags下的子目录的名称可由用户给定。 "},"page/1013.html":{"url":"page/1013.html","title":"语法","keywords":"","body":"语法 JSP页面 在传统的HTML页面文件中加入Java程序片和JSP标签，就构成了一个JSP页面。 JSP页面可由5种元素组合而成： HTML部分 ① 普通的HTML标记符； JSP部分 ② JSP标记，如指令标记、动作标记； Java部分 ③ 变量和方法的声明； ④ Java程序片； ⑤ Java表达式 ； JSP页面的运行原理： 把JSP页面中普通的HTML标记符号，交给客户的浏览器执行显示。 JSP标记、数据和方法声明、Java程序片由Tomcat服务器负责执行，将需要显示的结果发送给客户的浏览器。 Java表达式由Tomcat服务器负责计算，将结果转化为字符串，交给客户的浏览器负责显示。 JSP的5种元素 程序片创建Date对象： \"+date+\"\"); int m=100; %> 的因子之和是(不包括): JSP的5种元素 程序片创建Date对象： \"+date+\"\"); /* java块注释-在程序片内--客户端不可见 */ int m=100; %> 的因子之和是(不包括): Tag文件 简介 Tag文件是一种特殊的文本文件 Tag文件和JSP文件很类似，可以被JSP页面动态加载调用 目的是提高代码复用 有点像，调用函数时，被调用的函数，将被调用函数保存到一个文件以复用，并且用户无法直接访问 用户可访问性 用户不能通过该Tag文件所在Web服务目录直接访问这个Tag文件 文件结构 Tag文件是扩展名为.tag的文本文件，其结构几乎和JSP文件相同。 一个Tag文件中可以有普通的HTML标记符、某些特殊的指令标记、成员变量和方法的声明、Java程序片和Java表达式。 一个Tag文件对应着一个标记，该标记被习惯地称为Tag标记，将存放在同一目录中的若干个Tag文件所对应的Tag标记的全体称之为一个自定义标记库或简称为标记库。 这是一个Tab文件，负责计算1～100内的偶数之和： "},"page/1016.html":{"url":"page/1016.html","title":"HTML部分","keywords":"","body":"HTML部分 "},"page/1019.html":{"url":"page/1019.html","title":"标记","keywords":"","body":"标记 JSP页面可以含有HTML标记，当用户通过浏览器请求一个JSP页面时，Tomcat服务器将该JSP页面中的HTML标记直接发送到用户的浏览器，由用户的浏览器负责执行这些HTML标记。而JSP页面中的变量声明、程序片以及表达式由Tomcat服务器处理后，再将有关的结果用文本方式发送到用户端的浏览器。 HTML是Hypertext Marked Language的缩写，即超文本标记语言。 "},"page/1020.html":{"url":"page/1020.html","title":"注释","keywords":"","body":"注释 注释可以增强JSP页面的可读性，使JSP页面易于维护。JSP页面中的注释可分为三种。 JSP注释 HTML注释 Java注释 客户端可见性 不可见 可见 不可见 位置 主体部分，除了java程序片、表达式、声明内部 主体部分，除了java程序片、表达式、声明内部 java程序片、表达式、声明内部 形式 //单行注释 /* */多行注释 注意 不要在java程序片、表达式、声明内部 用户可见，不要在java程序片、表达式、声明内部 不要把结束标识%>给注释掉了 JSP的5种元素 程序片创建Date对象： \"+date+\"\"); /* java块注释-在程序片内--客户端不可见 */ int m=100; %> 的因子之和是(不包括): HTML注释 位置 主体部分，除了java程序片、表达式、声明内部 形式 HTML注释：在标记符号和-->之间加入注释内容： 用户可见性 JSP引擎把HTML注释交给用户，因此用户通过浏览器查看JSP页面的源文件时，能够看到HTML注释。 客户端可见 Java注释 位置 程序片内、表达式、声明部分 注意这三部分结尾标识%>不可以在注释里面否则会报错 形式 //单行注释 /* */多行注释 客户端可见性 客户端不可见 JSP注释 位置 主体部分，除了java程序片、表达式、声明内部 形式 JSP 注释：在标记符号和--%>之间加入注释内容： 用户可见性 JSP引擎忽略JSP注释，即在编译JSP页面时忽略JSP注释。 客户端不可见 "},"page/1017.html":{"url":"page/1017.html","title":"Java部分","keywords":"","body":"Java部分 "},"page/1021.html":{"url":"page/1021.html","title":"声明","keywords":"","body":"声明 在和%>标记符号之间声明变量和方法。 "},"page/1022.html":{"url":"page/1022.html","title":"变量声明","keywords":"","body":"变量声明 位置 在和%>之间放置Java的变量声明语句。 允许类型 变量的类型可以是Java语言允许的任何数据类型，将这些变量称为JSP页面的成员变量。 有效区域 和%>之间声明的变量在整个JSP页面内都有效， 与、%> 标记符在JSP页面中所在的书写位置无关。 当多个用户请求一个JSP页面时，JSP引擎为每个用户启动一个线程，这些线程由JSP引擎来管理，这些线程共享JSP页面的成员变量，因此任何一个用户对JSP页面成员变量操作的结果，都会影响到其他用户。 如果一个用户在执行Java程序片时调用JSP页面的方法操作成员变量，可能不希望其他用户也调用该方法操作成员变量，以免对其产生不利的影响,那么就应该将操作成员变量的方法用synchronized关键字修饰。 JSP引擎将JSP页面转译成Java 文件时，将、%> 标记符之间声明的变量作为类的成员变量，这些变量占有的内存空间直到JSP引擎关闭才释放。 利用成员变量被所有用户共享这一性质，实现了一个简单的计数器 简单网页访客数统计 您是第 个访问本站的客户。 通过synchronized方法操作一个成员变量来实现一个简单的计数器。 "},"page/1023.html":{"url":"page/1023.html","title":"方法声明","keywords":"","body":"方法声明 位置&有效范围 在和%>标记符号之间定义方法， 所定义的方法在整个JSP页面有效，可以在Java程序片中被调用。 注意 方法内声明的变量只在该方法内有效， 当方法被调用时，方法内声明的变量被分配内存，方法被调用完毕即可释放这些变量所占的内存。 在和%>之间定义了两个方法：multi (int x,int y)和div (int x,int y)，然后在程序片中调用这两个方法 调用getLength方法计算半径是\"+r+\"的园的周长：\"); double length=getLength(r); out.println(length); %> "},"page/1024.html":{"url":"page/1024.html","title":"程序片","keywords":"","body":"程序片 位置 在和%>之间插入Java程序片。 执行顺序 一个JSP页面可以有许多程序片,这些程序片将被JSP引擎按顺序执行。 局部变量 位置 程序片中声明的变量称为JSP页面的局部变量 。 分配方式 多个客户请求一个JSP页面时,Java程序片将被执行多次，分别在不同的线程中执行 ，分配各自局部变量 有效区域 一个JSP页面中的Java程序片会按其在页面中的顺序被执行,而且某个Java程序片中声明的局部变量在其后继的所有Java程序片以及表达式部分内都有效。 利用Java程序片的这个性质,有时候可以将一个Java程序片分割成几个Java程序片,然后在这些Java程序片之间再插入其他标记元素。 HTML标记 HTML标记 请输入E-mail： 您的E-mail地址中没有@。 您的E-mail地址含有非法的空格。 您的E-mail地址有两个以上的符号：@。 \"+str); %> 您的E-mail地址书写正确。 "},"page/1025.html":{"url":"page/1025.html","title":"表达式","keywords":"","body":"表达式 位置 可以在和%>之间插入一个表达式 是一个完整的符号，和=之间不要有空格 要求 这个表达式必须能求值 不可插入语句 注意 表达式的值由服务器负责计算，并将计算结果用字符串形式发送到用户端显示。 在JSP页面中，表达式的值被表示成一个字符串的形式，即Tomcat引擎将表达式的结果转换成字符串，然后发送给用户的浏览器。因此，在编写JSP页面时，要把Java表达式按普通的文本来使用。 Sin()除以等于 的平方是： 乘以等于 的平方根等于 大于吗？回答：x%> "},"page/1026.html":{"url":"page/1026.html","title":"内置对象","keywords":"","body":"内置对象 JSP内置对象 有些成员变量不用声明就可以在JSP页面的脚本（Java程序片和Java表达式）中使用，这就是所谓的内置对象。 内置对象有：resquest、response、session、out 、 application 。 "},"page/1027.html":{"url":"page/1027.html","title":"request","keywords":"","body":"request 简介 在JSP中，内置对象request封装了用户请求页面时所提交的信息，该对象调用相应的方法可以获取封装的信息. 即request对象可以获取用户提交的信息。 JSP页面使用request对象获取用户提交的数据，然后使用Tag标记调用Tag文件，并将必要的数据传递给Tag文件。Tag文件负责处理数据，根据需要将处理结果显示给用户或返回给调用它的JSP页面。 方法 request对象获取用户提交信息的最常用的方法是getParameter(String s). 可以用内置对象request对象来获取请求所提交的各类信息，request对象的常用方法如下： getProtocol()：获取请求使用的通信协议，如http/1.1等。 getServletPath()：获取请求的JSP页面所在的目录。 getContentLength()：获取HTTP请求的长度。 getMethod()：获取表单提交信息的方式，如POST或GET。 getHeader(String s)：获取请求中头的值。 getHeaderNames()：获取头名字的一个枚举。 getHeaders(String s)：获取头的全部值的一个枚举。 getRemoteAddr()：获取客户的IP地址。 getRemoteHost()：获取客户机的名称(如果获取不到，就获取IP地址). getServerName()：获取服务器的名称。 getServerPort()：获取服务器的端口号。 getParameterNames()：获取表单提交的信息体部分中name参数值的一个枚举. 注意 编码问题 当用request对象获取用户提交的汉字字符时,会出现乱码问题,所以对含有汉字字符的信息必须进行特殊的处理。 首先,将获取的字符串用ISO-8859-1进行编码，并将编码存放到一个字节数组中 然后再将这个数组转化为字符串对象即可 String str=request.getParameter(\"girl\"); byte b[]=str.getBytes(\"ISO-8859-1\"); str=new String(b); 用户在请求JSP页面时，通常会使用HTML表单提交信息，表单的一般格式是： 提交的具体内容 例如用户提交信息表单： tom.jsp页面可以使用内置request对象获得用户提交的信息request.getParameter(\"boy\"); demo.jsp页面通过表单向tree.jsp页面提交信息I am a student，tree.jsp页面通过request对象获取表单提交的信息，包括text的值以及按钮的值 demo.jsp tree.jsp 获取文本框提交的信息： 获取按钮的名字： 效果 demo.jsp页面通过表单向自己提交一个正数，demo.jsp页面获取表单提交的正数，并计算这个数的平方根。 表单中的action是所请求的页面，如果是当前页面，可以用双引号：\"\"代替当前页面，注意双引号中不能含有空格 demo.jsp =0){ r=Math.sqrt(number) ; out.print(\"\"+number+\"的平方根：\"); out.print(\"\"+r); } else out.print(\"\"+\"请输入一个正数\"); } catch(NumberFormatException e){ out.print(\"\"+\"请输入数字字符\"); } %> 效果 使用request对象的一些常用方法 demo.jsp mess.jsp 用户使用的协议是: 获取接受用户提交信息的页面： 接受用户提交信息的长度： 用户提交信息的方式： 获取HTTP头文件中User-Agent的值： 获取HTTP头文件中accept的值： 获取HTTP头文件中Host的值： 获取HTTP头文件中accept-encoding的值： 获取用户的IP地址： 获取用户机的名称： 获取服务器的名称： 获取服务器的端口号： 获取用户端提交的所有参数的名字： 获取头名字的一个枚举： 获取头文件中指定头名字的全部值的一个枚举： 文本框text提交的信息： 按钮的名字： 效果 用户通过demo.jsp中的表单将三角形的三边的长度提交给get.jsp，get.jsp使用Tag标记调用Tag文件Computer.tag，并将三角形三边的长度传递给Computer.tag，Computer.tag文件负责计算三角形的面积，并将计算结果返回给get.jsp页面。 demo.jsp 输入三角形三边： 边A: 边B: 边C: get.jsp \" b=\"\" c=\"\"/> 边A 边B 边C 面积 /WEB-INF/tags/Computer.jsp 效果 demo.jsp 效果 get.jsp "},"page/1028.html":{"url":"page/1028.html","title":"response","keywords":"","body":"response 可以用response对象对用户的请求做出动态响应，向用户端发送数据。 动态响应contentType属性 由于page指令只能为contentType属性指定一个值来决定响应的MIME类型。 如果想动态地改变这个属性的值来响应用户,就需要使用response对象的setContentType(String s)方法来改变contentType的属性值。 public void setContentType(String s)方法动态设置响应的MIME类型，参数s可取: text/html、text/plain image/gif、image/x-xbitmap、image/jpeg、image/pjpeg、 application/x-shockwave-flash application/vnd.ms-powerpoint、 application/vnd.ms-excel、application/msword。 当用户单击按钮，选择将当前页面保存为一个Word文档时,JSP页面动态地改变contentType属性的值为application/msword。这时,用户的浏览器会提示用户用MS-Word程序来显示或保存当前页面 demo.jsp 我正在学习response对象的 setContentType方法 将当前页面保存为word文档吗？ 效果 用response对象将contentType属性的值设为image/jpeg，使得用户可以看到Java程序片所绘制的图形 demo.jsp 观看旋转的椭圆 效果 response的HTTP文件头 response对象可以使用方法：addHeader(String head,String value);或使用方法：setHeader(String head ,String value);动态添加新的响应头和头的值，并将这些头发送给用户的浏览器。如果添加的头已经存在，则先前的头被覆盖。 response对象添加一个响应头refresh，其头值是5，那么用户收到这个头之后，5秒钟后将再次刷新该页面，导致该网页每5秒刷新一次 。 demo.jsp 现在的时间是： 效果 response重定向 在某些情况下，JSP引擎在响应用户时，可能需要将用户重新引导至另一个页面。 例如，如果用户输入的表单信息不完整，就会再次被引导到该表单的输入页面。 使用response对象的sendRedirect(URL url)方法实现用户的重定向。 forward动作标记不改变url,response改变 用户在demo.jsp页面填写表单提交给verify.jsp页面，如果填写的表单不完整就会被重新定向到demo.jsp页面 demo.jsp ÌîÐ´ÐÕÃû£º verify.jsp 　 效果 response的状态行 当JSP引擎对用户请求进行响应时，它发送的首行称做状态行。 状态行包括3位数字的状态代码和对状态代码的描述（称做原因短语）。 使用setStatus(int n)设置响应的状态行来防止本网站的JSP页面被“盗链”。other.jsp存放在Web服务目录ch3中(一个网站)；sameWebOne.jsp和sameWebTwo.jsp存放在同一Web服务目录ch4中(一个网站)。other.jsp和sameWebOne.jsp都提供了关于sameWebTwo.jsp的超链接。sameWebTwo.jsp允许sameWebOne.jsp通过其中的超链接访问它,但不允许other.jsp通过其中的超链接访问它 。 sameWebTwo.jsp 欢迎访问本页面! 您来自: other.jsp 和 sameWebOne.jsp 我是ch4服务目录中的页面 单击下面的超链接： 访问sameWebTwo.jsp 效果 "},"page/1029.html":{"url":"page/1029.html","title":"session","keywords":"","body":"session HTTP协议是一种无状态协议。一个用户向服务器发出请求（request），然后服务器返回响应（response），连接就被关闭了，在服务器端不保留连接的有关信息，因此当下一次连接时，服务器已没有以前的连接信息了，无法判断这一次连接和以前的连接是否属于同一用户。 内置session(会话)对象记录有关连接的信息.由Tomcat服务器负责创建。 session对象的Id 当一个用户首次访问Web服务目录中的某个JSP页面时，JSP引擎为其产生一个session对象。为用户产生的session对象调用相应的方法可以存储用户在访问各个页面期间提交的各种信息。 为用户产生的session对象中含有一个String类型的Id号，JSP引擎同时将这个Id号发送到用户端、存放在用户的浏览器的Cookie中。 每个用户都对应着一个session对象（该用户的会话），不同用户的session对象互不相同，即具有不同的Id号码。 用户在服务器的Web服务目录ch4中的三个页面first.jsp、second和third.jsp之间进行连接，三个页面的session对象是完全相同的。其中，first.jsp存放在ch4中，second.jsp存放在ch4的子目录two中，third.jsp存放在ch4的子目录three中。用户首先访问first.jsp页面，从这个页面再连接到second.jsp页面，然后从second.jsp再连接到third.jsp页面。first.jsp、second和third.jsp的效果图如图4.11（a），4.11（b），4.11（c） first.jsp 我是first.jsp页面,输入你的姓名连接到second.jsp 您的session对象的ID是：\"+id); %> second.jsp 我是second.jsp页面 \"+id); %> 单击超链接，连接到third.jsp的页面。 欢迎去third.jsp页面！ third.jsp 我是third.jsp页面 \"+id); %> 单击超链接，连接到first.jsp的页面。 欢迎去first.jsp！ session对象与URL重写 如果用户端不支持Cookie，那么用户在不同网页之间的session对象可能是互不相同的，因为如果服务器无法将Id存放到用户端，就不能建立session对象和用户的一一对应关系。 可以通过URL重写来实现session对象的惟一性。所谓URL重写，就是当用户从一个页面重新链接到另一个页面时，通过向这个新的URL添加参数，把session对象的Id传带过去，这样就可以保障用户在该网站各个页面中的session对象是完全相同的。可以使用response对象调用encodeURL()或encodeRedirectURL()方法实现URL重写. jiafei.jsp、tom.jsp和jerry.jsp之间实行URL重写，jiafei.jsp存放在ch4中，tom.jsp存放在ch4的子目录two中，jerry.jsp存放在ch4的子目录three中 jiafei.jsp 我是jiafei.jsp页面,输入你的姓名连接到tom.jsp 您的session对象的ID是：\"+id); %> \" method=post name=form> tom.jsp 我是tom.jsp页面 \"+id); %> 单击超链接，连接到jerry.jsp的页面。 \"> 欢迎去jerry.jsp页面！ jerry.jsp 我是jerry.jsp页面 \"+id); %> 单击超链接，连接到jiafei.jsp的页面。 \"> 欢迎去jiafeit.jsp！ session对象存储数据 session对象使用下列方法处理数据： （1）public void setAttribute(String key, Object obj) session对象可以调用该方法将参数Object指定的对象obj添加到session对象中，并为添加的对象指定了一个索引关键字，如果添加的两个对象的关键字相同，则先前添加的对象被清除。 （2）public Object getAttibute(String key) 获取session对象含有的关键字是key的对象。由于任何对象都可以添加到session对象中，因此用该方法取回对象时，应强制转化为原来的类型。 （3）public Enumeration getAttributeNames() session对象调用该方法产生一个枚举对象，该枚举对象使用nextElemets()遍历session中的各个对象所对应的关键字。 （4）public long getCreationTime() session对象调用该方法可以获取该对象创建的时间，单位是毫秒。 （5）public void removeAttribute(String name) session对象调用该方法移掉关键字key对应的对象. 3个页面demo.jsp，shop.jsp和account.jsp，我们使用session对象存储顾客的姓名和购买的商品 demo.jsp 输入您的姓名连接到第一百货：shop.jsp shop.jsp 这里是第一百货。输入您想购买的商品连接到结账：account.jsp。 account.jsp 这里是结账处,的姓名是： 您选择购买的商品是： 效果 session对象在Tag文件中使用 JSP页面通过调用Tag文件可以实现代码的复用，那么在反复调用Tag文件时，Tag文件就可以对session对象中存储的数据进行处理，并将必要的结果返回给JSP页面。 猜数字的小游戏。当用户访问服务器上的demo.jsp页面时，服务器随机分配给用户一个1至100之间的整数，然后将这个整数存在用户的session对象中。 demo.jsp 随机分给了你一个1到100之间的数，请猜！ 去猜测这个数 guess.jsp \" /> 当前猜测结果： 重新获得随机数 输入您的猜测： WEB-INF/tag/GuessTag.tag realnumber){ int n=((Integer)session.getAttribute(\"count\")).intValue(); n=n+1; session.setAttribute(\"count\",new Integer(n)); mess=\"您猜大了,这是第\"+n+\"次猜测\"; } else if(guessNumber session对象的生存期限 一个用户在某个web服务目录的session对象的生存期限 依赖于session对象是否调用invalidate()方法使得session无效 依赖于session对象达到了设置的最长的“发呆”状态时间 依赖于服务器是否被关闭。 重新设置各个Web服务目录下的session对象的最长“发呆”时间。打开Tomcat安装目录conf目录下的配置文件web.xml，找到 30 将其中的30修改成所要求的值即可,如果时间修改为负数,发呆时间不受限制。 session对象可以使用下列方法获取或设置和生存时间有关的信息： public long getCreationTime() 获取session创建的时间，单位是毫秒。 public long getLastAccessedTime() 获取session最后一次被操作的时间。 public int getMaxInactiveInterval() 获取session（单位是秒）。最长的“发呆”时间 public void setMaxInactiveInterval(int interval) 设置session最长的“发呆”时间 public boolean isNew() 判断session是否是一个新建的对象。 invalidate() 使session无效。 session对象使用setMaxInactiveInterval(int interval)方法设置最长的“发呆”状态时间为10秒。用户可以通过刷新页面检查是否达到了最长的“发呆”时间，如果两次刷新之间的间隔超过10秒，用户先前的session将被取消，用户将获得一个新的session对象。 demo.jsp 如果你第一次访问当前web服务目录，您的会话是新的\"); out.println(\"如果你不是首次访问当前web服务目录，您的会话不是新的\"); out.println(\"会话是新的吗？：\"+boo); out.println(\"欢迎来到本页面，您的session允许的最长发呆时间为\"+ session.getMaxInactiveInterval()+\"秒\"); out.println(\"您的session的创建时间是\"+new Date(session.getCreationTime())); out.println(\"您的session的Id是\"+session.getId()); Long lastTime=(Long)session.getAttribute(\"lastTime\"); if(lastTime==null){ long n=session.getLastAccessedTime(); session.setAttribute(\"lastTime\",new Long(n)); } else{ long m=session.getLastAccessedTime(); long n=((Long)session.getAttribute(\"lastTime\")).longValue(); out.println(\"您的发呆时间大约是\"+(m-n)+\"毫秒,大约\"+(m-n)/1000+\"秒\"); session.setAttribute(\"lastTime\",new Long(m)); } %> 使用session设置时间间隔 为了限制用户在很短的时间间隔内不断地使用某页面所提供的某种功能，而影响其他用户使用该页面所提供的功能，因此我们可以利用用户的session来设置用户使用当前页面所提供功能的间隔时间，从而限制该用户等待若干“时间”后，再次使用该页面所提供的功能。 demo.jsp提供计算字符串长度的功能，用户可以通过表单提交一个字符串给当前页面。demo.jsp利用用户的session来设置用户使用当前页面的所提供功能的间隔时间（间隔时间是5秒） demo.jsp 反复使用该页面提供的计算字符串长度功能的间隔时间必须大于5秒。 输入一个字符串，页面将计算它的长度： 计数器 使用session实现计数器的步骤是：当一个用户请求Web服务目录下的任何一个JSP页面时，首先检查该用户的session对象中是否已经有计数，如果没有计数，立刻将当前的计数增1，并将计数存到用户的session中，否则不改变当前的计数。 Web服务目录ch4有两个JSP页面：one.jsp、two.jsp和一个tag文件：Count.tag 。Count.tag文件负责计数。one.jsp、two.jsp使用Count.tag实现计数。用户首次请求one.jsp和two.jsp的任何一个，都会使得网站的计数增1 one.jsp 欢迎访问本站 欢迎去two.jsp参观 two.jsp 欢迎访问本站 欢迎去one.jsp参观 WEB-INF/tags/Count.tag 您是第 个访问本网站的用户。 "},"page/1030.html":{"url":"page/1030.html","title":"application","keywords":"","body":"application 任何客户在所访问的服务目录的各个页面浏览时，application对象都是同一个. application对象的常用方法 （1）public void setAttribute(String key, Object obj) application对象可以调用该方法将参数Object指定的对象 obj添加到application对象中，并为添加的对象指定了一个索引关键字，如果添加的两个对象的关键字相同，则先前添加对象被清除。 （2）public Object getAttibute(String key) 获取application对象含有的关键字是key的对象。由于任何对象都可以添加到application对象中，因此用该方法取回对象时，应强制转化为原来的类型。 （3）public Enumeration getAttributeNames() application对象调用该方法产生一个枚举对象，该枚举对象使用nextElemets()遍历application中的各个对象所对应的关键字。 （4）public void removeAttribue(String key) 从当前application对象中删除关键字是key的对象。 （5）public String getServletInfo() application对象可以调用该方法获取Servlet编译器的当前版本的信息。 用户通过submit.jsp页面向messagePane.jsp页面提交姓名、留言标题和留言内容，messagePane.jsp页面获取这些内容后，用同步方法将这些内容添加到一个向量中，然后将这个向量再添加到application对象中。当用户单击查看留言板时，showMessage.jsp页面负责显示所有用户的留言内容，即从application对象中取出向量，然后遍历向量中存储的信息 。 submit.jsp 输入您的名字： 输入您的留言标题： 输入您的留言： messagePane.jsp v=new Vector(); int i=0; ServletContext application; synchronized void sendMessage(String s){ application=getServletContext();; v.add(s); application.setAttribute(\"Mess\",v); } %> 返回留言板 查看留言板 showMessage.jsp v=(Vector)application.getAttribute(\"Mess\"); out.print(\"\"); out.print(\"\"); out.print(\"\"+\"留言者姓名\"+\"\"); out.print(\"\"+\"留言标题\"+\"\"); out.print(\"\"+\"留言时间\"+\"\"); out.print(\"\"+\"留言内容\"+\"\"); for(int i=0;i\"); String message=v.elementAt(i); byte bb[]=message.getBytes(\"iso-8859-1\"); message=new String(bb); String a[]=message.split(\"#\"); out.print(\"\"); int number=a.length-1; for(int k=0;k\"+a[k]+\"\"); else out.print(\"\"+a[k]+\" \"); } out.print(\"\"); } out.print(\"\"); %> 返回留言板 "},"page/1031.html":{"url":"page/1031.html","title":"out","keywords":"","body":"out out对象是一个输出流,用来向用户端输出数据。 out对象可调用如下的方法用于各种数据的输出， out.print(Boolean)，out.println(Boolean) 用于输出一个布尔值。 out.print(char)，out.println(char) 输出一个字符。 out.print(double)，out.println(double) 输出一个双精度的浮点数。 out.print(float)，out.println(float) 用于输出一个单精度的浮点数。 out.print(long)，out.println(long) 输出一个长整型数据。 out.print(String)，out.println(String) 输出一个字符串对象的内容。 out.newLine() 输出一个换行符。 out.flush() 输出缓冲区里的内容。 out.close() 关闭流 使用out对象向用户输出包括表格等内容的信息 demo.jsp 这是标题1字体的大小\"); out.println(\"这是标题2字体的大小\"); out.print(\"\"); out.println(a); out.println(b); out.println(c); %> 以下是一个表格 \"); out.println(\"\"); out.println(\"\"); out.println(\"\"+\"姓名\"+\"\"); out.println(\"\"+\"性别\"+\"\"); out.println(\"\"+\"出生日期\"+\"\"); out.println(\"\"); out.println(\"\"); out.println(\"\"+\"刘甲一\"+\"\"); out.println(\"\"+\"男\"+\"\"); out.println(\"\"+\"1978年5月\"+\"\"); out.println(\"\"); out.println(\"\"); out.println(\"\"+\"林　霞\"+\"\"); out.println(\"\"+\"女\"+\"\"); out.println(\"\"+\"1979年8月\"+\"\"); out.println(\"\"); out.println(\"\"); out.print(\"\") ; %> "},"page/1037.html":{"url":"page/1037.html","title":"Javabean","keywords":"","body":"Javabean Javabean是一种Java类，通过封装属性和方法成为具有某种功能或者处理某个业务的对象，简称bean。具有以下特点： 1.可以实现代码的重复利用。 2.易编写、易维护、易使用。 3.可以在任何安装了Java运行环境的平台上的使用，而不需要重新编译。 JSP页面可以将数据的处理过程指派给一个或几个bean来完成，即JSP页面调用bean完成数据的处理，并将有关处理结果存放bean中.JSP页面可以使用Java程序片或某些JSP指令标记显示bean中的数据，即JSP页面的主要工作是显示数据，不负责数据的逻辑业务处理，如图4.1所示意。 编写Javabean和使用Javabean ​ Javabean分为可视组件和非可视组件。在JSP中主要使用非可视组件。对于非可视组件，我们不必去设计它的外观，主要关心它的属性和方法。 ​ 编写Javabean就是编写一个Java的类，所以只要会写类就能编写一个Javabean，这个类创建的一个对象称为一个Javabean，简称bean. 编写JavaBean ​ 为了能让使用这个bean的应用程序构建工具（比如JSP引擎）知道这个bean的属性和方法，只需在类的方法命名上遵守以下规则: 1.如果类的成员变量的名字是xxx，类中提供两个方法： getXxx()，用来获取属性xxx。 setXxx()，用来修改属性xxx.。 后缀是将成员变量名字的首字母大写的字符序列。 2.对于boolean类型的成员变量，即布尔逻辑类型的属性，允许使用“is”代替上面的“get”和“set”。 3.类中声明的方法的访问属性都必须是public的。 4.类中需提供public、无参数的构造方法。 Java文件保存为Circle.java，并编译通过，得到字节码文件Circle.class //Circle.java package tom.jiafei; public class Circle { double radius; public Circle() { radius=1; } public double getRadius() { return radius; } public void setRadius(double newRadius) { radius=newRadius; } public double circleArea() { return Math.PI*radius*radius; } public double circlLength() { return 2.0*Math.PI*radius; } } 保存bean的字节码 1．在当前Web服务目录下建立子目录结构：\\WEB-INF\\classes，然后根据类的包名，在classes下再建立相应的子目录，比如类的包名为tom.jiafei，那么在classes下建立子目录结构：tom\\jiafei 使用bean 使用JSP动作标记：useBean，来加载使用bean。useBean标记的语法格式： 或 例如： 原理 bean的加载原理 当JSP页面使用JSP需要使用一个bean时，JSP引擎将首先根据JSP动作标记给出的bean的id,以及scope，查找JSP引擎内置pageContent对象中是否含有这样的bean，如果这样的bean存在，JSP引擎就分配这样的bean给用户。 如果在pageContent中没有查找到JSP动作标记要求的bean，就根据class指定的字节码创建一个JSP动作标记要求的bean，并将所创建的bean添加到pageContent内置对象中。 bean的有效范围（生命周期） scope取值范围给出了bean的存活时间(生命周期)，即scope取值决定了JSP引擎分配给用户的bean的存活时间 page 有效范围是当前页面.不同用户的scope取值是page的bean也是互不相同的. request bean的有效范围是request期间。不同用户的scope取值是request的bean也是互不相同的。 session 有效范围是用户的session(会话)期间。不同用户(即不同浏览器)的scope取值是session的bean是互不相同的（占有不同的内存空间）。 application bean的有效范围是application期间。JSP引擎为Web服务目录下所有的JSP页面分配一个共享的bean，不同用户的scope取值是application的bean也都是相同的一个. 负责创建bean的类是上述的Circle类，创建的bean的名字是circle， circle的scope取值是page。 圆的初始半径是： 修改半径为 目前圆的半径是： 圆的周长是： 圆的面积是： 获取和修改beans的属性 ​ JSP页面使用getProperty、setProperty标记获取或修改属性xxx时，必须保证bean有相应的getXxx和setXxx方法，即对方法的名字的命名有特殊的要求，而在程序片中直接用bean调用方法就不需要方法命名遵守getXxx和setXxx规则。 getProperty动作标记 ​ 使用getProperty动作标记可以获得bean的属性值，并将这个值用串的形式发送给用户的浏览器。使用getProperty动作标记之前，必须使用useBean动作标记获得相应的bean。 或 该指令相当于Java表达式： setProperty动作标记 ​ 使用setProperty动作标记可以设置bean的属性值。使用这个标记之前，必须使用useBean标记得到一个相应的bean。 （1）将bean属性的值设置为一个表达式的值或字符串 将bena属性的值设置为一个表达式的值的语法格式 \"/> 将bena属性的值设置为一个字符串语法格式 ​ 在JSP页面中使用动作标记设置、获取该bean的属性值。 ​ 把Student.java编译生成的字节码Student.class复制到\\ch4\\WEB-INF\\classes\\tom\\jiafei中。 ​ 建议把Student.java保存在\\ch4\\WEB-INF\\classes\\tom\\jiafei中，然后按如下格式编译 ​ classes> javac tom\\jiafei\\Student.java main.jsp 学生姓名： \"/> 学生身高：米 Student.java package tom.jiafei; public class Student { String name=null; double height; public String getName() { return name; } public void setName(String newName){ name=newName; } public double getHeight() { return height; } public void setHeight(double newHeight) { height=newHeight; } } （2）通过HTTP表单的参数的值来设置bean的相应属性的值 用HTTP表单的所有参数的值设置bean相对应的属性的值： 用HTTP表单的某个参数的值设置bean的某个属性的值 例子5中使用Goods类来创建bean，JSP页面获取的bean的id是iPhone，bean的scope是request，JSP页面example4_5_a.jsp和example4_5_b.jsp都是通过表单来指定iPhone的属性值。例子5中example4_5_a.jsp和example4_5_b.jsp的效果如图4.10(a)和4.10(b)。 Goods.java package tom.jiafei; public class Goods { String name=\"无名\"; double price=0; public String getName() { return name; } public void setName(String newName){ try{ byte [] bb = newName.getBytes(\"iso-8859-1\"); newName = new String(bb); } catch(Exception exp){} name=newName; } public double getPrice() { return price; } public void setPrice(double newPrice) { price=newPrice; } } 这里是example4_2_a.jsp页面 圆的半径是： example4_2_b.jsp 这里是example4_2_b.jsp页面 当前圆的半径是： 修改后的圆的半径是： example4_2_a.jsp beans的辅助类 有时在写一个bean的时候，除了需要用import语句引入JDK平台提供的类，可能还需要其它自己编写的一些类。 那么只要将这些类和创建bean的类写在一个java源文件中即可，但必须将源文件编译后产生的全部字节码文件复制到相应的目录中 ​ 使用一个bean列出JSP页面所在目录中特定扩展名的文件。 ​ 在写bean的类文件ListFile时，我们需要一个实现FilenameFilter接口的辅助类FileExtendName，该类可以帮助bean列出指定扩展名的文件（把ListFile.java编译生成的字节码ListFile.class和FileExtendName.class复制到\\ch4\\WEB-INF\\classes\\tom\\jiafei中）。 ​ 用户通过表单设置bean的extendsName属性的值，bean列出目录中由extendsName属性值指定的扩展名的文件。example4_6.jsp的效果如图4.11所示。 ListFile.java package tom.jiafei; import java.io.*; class FileExtendName implements FilenameFilter { String str=null; FileExtendName (String s) { str=\".\"+s; } public boolean accept(File dir,String name) { return name.endsWith(str); } } public class ListFile { String extendsName=null; String [] allFileName=null; String dir=null; public void setDir(String dir) { this.dir =dir; } public String getDir() { return dir; } public void setExtendsName(String s) { extendsName=s; } public String getExtendsName() { return extendsName; } public String [] getAllFileName() { if(dir!=null) { File mulu=new File(dir); FileExtendName help=new FileExtendName(extendsName); allFileName=mulu.list(help); } return allFileName; } } 输入目录名，例如:D:/2000 输入文件的扩展名,例如:java 目录 中 扩展名是 的文件有： \"+fileName[i]); } } %> JSP与bean结合的简单例子 ​ 在本节中，创建bean的类的包名都是red.star，使用的Web服务目录仍然是ch4，因此，需要在ch4下建立如下的目录结构：ch4\\WEB-INF\\classes\\red\\star创建bean的字节码文件都需要保存在上述目录中。 ​ 为了调试程序方便，可以将源文件保存在Web服务目录ch4的WEB-INF\\classes\\red\\star目录中，然后在进入包名形成的目录的父目录(classes)中，编译源文件：classes> javac red\\star\\源文件名 三角形 ​ 例子7使用bean（Triangle类负责创建）完成三角形的有关数据的处理。例子中的JSP页面提供一个表单，用户可以通过表单将三角形三边的长度提交给该页面。 ​ 用户提交表单后，JSP页面将计算三角形面积的任务交给一个bean去完成。例子中example4_7.jsp的效果如图4.12所示。 输入三角形三边： 边A: 边B: 边C: 三角形的三边是： , , . 这三个边能构成一个三角形吗？ 面积是: package red.star; public class Triangle { double sideA=-1,sideB=-1,sideC=-1, area=-1; boolean triangle; public void setSideA(double a) { sideA=a; } public double getSideA() { return sideA; } public void setSideB(double b) { sideB=b; } public double getSideB() { return sideB; } public void setSideC(double c) { sideC=c; } public double getSideC() { return sideC; } public double getArea() { double p=(sideA+sideB+sideC)/2.0; if(triangle) area=Math.sqrt(p*(p-sideA)*(p-sideB)*(p-sideC)); return area; } public boolean isTriangle() { if(sideA 四则运算bean ​ 例子8使用bean（CompuerBean类负责创建）完成四则运算。例子中的JSP页面提供一个表单，用户可以通过表单输入两个数和四则运算符号提交给该页面。用户提交表单后，JSP页面将计算任务交给一个bean去完成。例子中example4_8.jsp的效果如图4.13所示。 + - * / = package red.star; public class ComputerBean { double numberOne,numberTwo,result; String operator=\"+\"; public void setNumberOne(double n) { numberOne=n; } public double getNumberOne() { return numberOne; } public void setNumberTwo(double n) { numberTwo=n; } public double getNumberTwo() { return numberTwo; } public void setOperator(String s) { operator=s.trim();; } public String getOperator() { return operator; } public double getResult() { if(operator.equals(\"+\")) result=numberOne+numberTwo; else if(operator.equals(\"-\")) result=numberOne-numberTwo; else if(operator.equals(\"*\")) result=numberOne*numberTwo; else if(operator.equals(\"/\")) result=numberOne/numberTwo; return result; } } 浏览图像 bean ​ 例子9使用bean（Play类负责创建）获取图像的名字并将图像排序。例子中的JSP页面通过表单提交图像的序号给bean显示，比如单击表单上的“下一张”或“上一张”，用户提交表单后，JSP页面将获取图像名字的任务交给一个bean去完成，JSP页面根据bean获得的图像名字显示图像。例子中example4_9.jsp的效果如图4.14所示。 \"/> width =120 height =90>这是当前显示的图像 单击\"上一张\"或\"下一张\"按钮浏览图像 \"> \"> package red.star; import java.io.*; public class Play { int imageNumber=0,max; String pictureName[],playImage; String webDir=\"\"; //web服务目录的名字 String tomcatDir; //tomcat的安装目录 public Play() { File f= new File(\"\"); //该文件认为在Tomcat引擎启动的目录中，即bin目录中 String path = f.getAbsolutePath(); int index = path.indexOf(\"bin\"); tomcatDir = path.substring(0,index); } public void setWebDir(String s) { webDir =s; if(pictureName==null) { File dirImage=new File(tomcatDir+\"/webapps/\"+webDir+\"/image\"); pictureName=dirImage.list(); } if(pictureName!=null) max=pictureName.length; } public void setImageNumber(int n){ if(n 计数器bean ​ 例子10中有两个供用户访问的JSP页面：example4_10_a.jsp、example4_10_b.jsp，这两个页面调用bean(CounterCount类负责创建)实现计数。 ​ 用户首次请求example4_10_a.jsp和example4_10_b.jsp的任何一个，都会使得网站的总计数增1。 ​ 用户访问过Web服务目录的某页面后，再访问该Web服务目录任何页面不能再增加总计数。example4_10_a.jsp和example4_10_b.jsp效果如图4.15(a)和4.15(b)所示。 网站的example4_10_a.jsp页面 您是第 个访问者。 欢迎去example4_10_b.jsp参观 网站的example4_10_b.jsp页面 您是第 个访问者。 欢迎去example4_10_a.jsp参观 package red.star; import java.io.*; public class ComputerCount { int number=0; boolean isCome=false; File file=new File(\"count.dat\") ; private void countPeople() { if(!file.exists()) { number++; try { file.createNewFile(); FileOutputStream out=new FileOutputStream(file); DataOutputStream dataOut=new DataOutputStream(out); dataOut.writeInt(number); out.close(); dataOut.close(); } catch(IOException ee){} } else { try{ FileInputStream in=new FileInputStream(file); DataInputStream dataIn=new DataInputStream(in); number=dataIn.readInt(); number++; in.close(); dataIn.close(); FileOutputStream out=new FileOutputStream(file); DataOutputStream dataOut=new DataOutputStream(out); dataOut.writeInt(number); out.close(); dataOut.close(); } catch(IOException ee){} } isCome=true; } public int getNumber(){ if(isCome==false) countPeople(); return number; } } Javabean是一个可重复使用的软件组件，是遵循一定标准、用Java语言编写的一个类，该类的一个实例称作一个Javabean。 一个JSP页面可以将数据的处理过程指派给一个或几个bean来完成，我们只需在JSP页面中调用这个bean即可。在JSP页面中调用bean可以将数据的处理代码从页面中分离出来，实现代码服用，更有效维护一个Web应用. bean的生命周期分为page、request、session和application "},"page/1038.html":{"url":"page/1038.html","title":"JavaServlet","keywords":"","body":"JavaServlet 概述 ​ 有些Web应用可能只需要JSP+Javabean就能设计的很好，但是有些Web应用，就可能需要JSP+Javabean+servlet来完成，即需要服务器再创建一些servlet，配合JSP页面来完成整个Web应用程序的工作，关于这一点将在MVC模式中讲述。 ​ 本章将使用javax.servlet.http包中的类， javax.servlet.http包不在JDK的核心类库中，因此需要将Tomcat安装目录lib子目录中的servlet-api.jar文件复制到Tomcat服务器所使用的JDK的扩展目录中，比如，复制到D:\\jdk1.7\\jre\\lib\\ext中。 servlet的部署、创建与运行 ​ Java Servlet的核心思想是在服务器端创建能响应用户请求的对象，即创建servlet，简称servlet。因此，学习Java Servlet的首要任务是掌握怎样编写创建servlet的类、怎样在Tomcat服务器上保存编译这个类所得到的字节码、怎样编写部署文件、怎样请求Tomcat服务器创建一个servlet。 源文件及字节码 Servlet类 ​ 写一个创建servlet的类就是编写一个特殊类的子类，这个特殊的类就是javax.servlet.http包中的HttpServlet类。这样的子类创建的对象习惯地被称作一个servlet。 ​ 例子1中的Example5_1_Servlet.java是一个简单的Servlet类，该类创建的servlet可以响应用户的请求。 package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example5_1_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void service(HttpServletRequest reqest,HttpServletResponse response) throws IOException{ reqest.setCharacterEncoding(\"gb2312\"); String str=reqest.getParameter(\"moon\"); response.setContentType(\"text/html;charset=gb2312\");//设置响应的MIME类型 PrintWriter out=response.getWriter();//获得一个向用户发送数据的输出流 String sevletName=getServletName(); out.println(\"\"); out.println(\"请求的servlet的名字是\"+sevletName+\"\"); out.println(\"servlet在Web设计中非常重要（见稍后的第6章)\"); if(str!=null&&str.length()>=1) out.println(\"\"+str+\"\"); out.println(\"\"); } } 字节码文件的保存 ​ 为了调试代码的方便，可以事先将创建servlet的类的源文件，按着其包名，保存到Web服务目录的下述子目录中：\\WEB-INF\\classes\\myservlet\\control 然后按如下格式编译源文件（如图5.1）： classes>javac myservlet\\control\\Servlet源文件 例如： classes>javac myservlet\\control\\Example5_1_Servlet.java 编写部署文件web.xml ​ Servlet类的字节码保存到指定的目录后，必须为Tomcat服务器编写一个部署文件，只有这样，Tomcat服务器才会按用户的请求使用Servlet字节码文件创建对象。 ​ 编写的web.xml文件需要保存到Web服务目录的WEB-INF子目录中，比如ch5\\WEB-INF中。根据例子1给出的Servlet类，我们编写的web.xml文件的内容如下）： hello myservlet.control.Example5_1_Servlet hello /lookHello 标记及子标记 标记需要有2个子标记： 和 其中标记的内容是创建的servlet的名字. 标记的内容指定用哪个Servlet类来创建servlet。 标记及子标记 一个``标记会对应地出现一个``标记，``标记需要有两个子标记： 和. 其中标记的是创建的servlet的名字,标记用来指定用户用怎样的URL格式来请求servlet， 比如，标记的内容是：/lookHello， 那么用户必须在浏览器的地址栏中键入： http://127.0.0.1:8080/ch5/lookHello 来请求名字是hello的servlet。 servlet的创建与运行 ​ servlet由Tomcat服务器负责创建，Web设计者只需为Tomcat服务器预备好Servlet类的字节码文件、编写好相应的配置文件web.xml即可。用户就可以根据web.xml部署文件来请求服务器创建并运行一个servlet。 ​ 现在，用户就可以请求例子1给出的Servlet类所创建的名字是hello的servlet了，根据5.2中的web.xml文件，用户需在浏览器键入： ​ http://127.0.0.1:8080/ch5/lookHello 请求服务器运行名字是hello的servlet，效果如图5.4(a)所示。 向servlet传递参数的值 ​ 在请求一个servlet时，可以在请求的url-pattern中额外的加入参数及其值，格式是： servlet名?参数1=值1&参数2=值…参数n=值 那么被请求的servlet就可以使用request对象获取参数的值，例如： request.getParameter(参数n) 比如可以在浏览器的浏览器键入： http://127.0.0.1:8080/ch5/lookHello?moon=loveliness 请求例子1中的servlet，并向其传递参数moon的值：\"loveliness\",运行效果如图5.4(b)所示。 servlet的工作原理 ​ servlet是javax.servlet包中HttpServlet类的子类的一个实例、由服务器负责创建并完成初始化工作。当多个用户请求一个servlet时，服务器为每个用户启动一个线程而不是启动一个进程，这些线程由服务器来管理，与传统的CGI为每个用户启动一个进程相比较，效率要高的多。 servlet 对象的生命周期 一个servlet的生命周期主要有下列三个过程组成： 初始化servlet。servlet第一次被请求加载时，服务器初始化这个servlet，即创建一个servlet，这servlet调用init方法完成必要的初始化工作。 诞生的servlet再调用service方法响应用户的请求。 当服务器关闭时，调用destroy方法，消灭servlet。 ​ init方法只被调用一次，即在servlet第一次被请求加载时调用该方法。当后续的用户请求servlet服务时，Web服务将启动一个新的线程，在该线程中，servlet调用service方法响应用户的请求，也就是说，每个用户的每次请求都导致service方法被调用执行，其执行过程分别运行在不同的线程中。 init方法 ​ 该方法是HttpServlet类中的方法，可以在子类中重写这个方法。init方法的声明格式： ​ public void init(ServletConfig config) throws ServletException servlet第一次被请求加载时，服务器创建一个servlet，这个对象调用init方法完成必要的初始化工作。 init方法只被调用一次，即在servlet第一次被请求加载时调用该方法。 service方法 ​ 该方法是HttpServlet类中的方法，我们可以在子类中直接继承该方法或重写这个方法。service方法的声明格式： public void service(HttpServletRequest request HttpServletResponse response) throw ServletException,IOException ​ 当后续的用户请求该servlet时，服务器将启动一个新的线程，在该线程中，servlet调用service方法响应用户的请求，即每个用户的请求都导致service方法被调用执行，调用过程运行在不同的线程中，互不干扰。 destroy方法 ​ 该方法是HttpServlet类中的方法，子类可直接继承这个方法，一般不需要重写。destroy方法的声明格式： ​ public destroy() ​ 当服务器终止服务时，比如关闭服务器等，destroy()方法会被执行，消灭servlet。 通过JSP页面访问servlet ​ 用户除了可以在浏览器的地址栏中直接键入servlet的请求格式来请求运行一个servlet外，也可以通过JSP页面来请求一个servlet。也就是说，可以让JSP页面负责数据的显示，而让一个servlet去做和处理数据有关的事情。 ​ 需要特别注意的是，如果web.xml文件中标记的子标记指定的请求servlet的格式是“/lookHello”，那么JSP页面请求servlet时，必须要写成 “lookHello”，不可以写成“/lookHello”，否则将变成请求root服务目录下的某个servlet。 通过表单向servlet提交数据 ​ 如果web.xml文件中指定的请求servlet的格式是\"/computeBill\",那么form表单中action给出的值就是\"computeBill \"，如下所示意： ​ 当请求一个servlet时，可以加入参数及其值，格式是： ​ servlet名?参数1=值1&参数2=值…参数n=值 例如： ​ 例子2中，JSP页面example5_2.jsp通过表单请求名字是名字为computeBill的servlet，并向所请求的servlet提交一个账单明细，例如：“洗衣粉:12.8圆，可乐：12圆，泡菜:0.8圆”，computeBill负责计算账单的消费额。example5_2.jsp的效果如图5.5(a)所示, 名字为computeBill的servlet运行效果如图5.5(b)所示。 ch5/example5_2.jsp 输入账单： 洗衣粉:12.8圆，可乐：12圆，泡菜:0.8圆 名字是computeBill的servlet由Example5_2_Servlet类负责创建，访问它的url-pattern是computeBill，需要为ch5\\WEN-INF目录下的web.xml文件添加如下的子标记： ch5/WEB-INF/web.xml computeBill myservlet.control.Example5_2_Servlet computeBill /computeBill ​ Example5_2_Servlet类负责创建名字是computeBill的servlet,所创建的servlet使用request获取用户提交的数据。Example5_2_Servlet创建的servlet的运行效果 如图5.5(b)所示。 ch5/WEB-INF/classes/myservlet/control/Example5_2_Servlet.java package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example5_2_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void service(HttpServletRequest request,HttpServletResponse response) throws IOException{ request.setCharacterEncoding(\"gb2312\"); response.setContentType(\"text/html;charset=gb2312\"); PrintWriter out=response.getWriter(); out.println(\"\"); String str=request.getParameter(\"billMess\"); if(str==null||str.length()==0) return; String []price = str.split(\"[^0123456789.]+\"); double sum = 0; try{ for(int i=0;i=1) sum+=Double.parseDouble(price[i]); } } catch(NumberFormatException e){ out.print(\" \"+e); } out.print(\"\\\"\"+str+\"\\\"的消费额:\"+sum+\"圆\"); out.println(\"\"); } } 通过超链接访问servlet ​ 如果web.xml文件中指定的请求servlet的格式是\"/triangle\",那么超链接标记中href的值是\" triangle \"，如下所示意： ​ ​ 例子3使用超链接请求servlet，并向所请求的servlet传递值。JSP页面example5_3.jsp中单击一个超链接，请求一个名字为triangle的servlet，并将三角形的三个边的长度提交给所请求的servlet，servlet负责计算三角形的面积。 ​ example5_3.jsp中单击一个超链接，请求一个名字为triangle的servlet，并将三角形的三个边的长度提交给所请求的servlet，servlet负责计算三角形的面积。example5_3.jsp的效果如图5.6(a)所示。 三角形（3,4,5）的面积 名字是triangle的servlet由Example5_3_Servlet类负责创建，访问它的url-pattern是/triangle，需要为ch5\\WEN-INF目录下的web.xml文件添加如下的子标记： web.xml配置文件 triangle myservlet.control.Example5_3_Servlet triangle /triangle ​ Example5_3_Servlet类负责创建servlet,所创建的servlet使用request获取用户提交的三角形三边的值，并计算三角形的面积。Example5_3_Servlet创建的servlet的运行效果如图5.6(b)。 package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example5_3_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void service(HttpServletRequest request,HttpServletResponse response) throws IOException{ request.setCharacterEncoding(\"gb2312\"); response.setContentType(\"text/html;charset=gb2312\"); PrintWriter out=response.getWriter(); out.println(\"\"); String a=request.getParameter(\"sideA\"); String b=request.getParameter(\"sideB\"); String c=request.getParameter(\"sideC\"); if(a==null||a.length()==0) return; double sideA=0,sideB=0,sideC=0; try { sideA = Double.parseDouble(a); sideB = Double.parseDouble(b); sideC = Double.parseDouble(c); } catch(NumberFormatException exp){ return; } double area = 0,p=0; p = (sideA+sideB+sideC)/2; area = Math.sqrt(p*(p-sideA)*(p-sideB)*(p-sideC)); out.print(\"三角形\"+a+\",\"+b+\",\"+c+\"的面积是\"+area); out.println(\"\"); } } 共享变量 ​ 对于Servlet类所创建的servlet的,用户将共享该servlet的成员变量。 数学上有一个计算 的公式： 例子5_4利用成员变量被所有用户共享这一特性实现用户帮助计算。 ​ 单击JSP页面example5_4.jsp的超链接访问名字为computerPI的servlet，该servlet负责计算π的近似值。example5_4.jsp的效果如图5.7(a)所示 参与计算PI的值 名字是computerPI的servlet由Example5_4_Servlet类负责创建，访问它的url-pattern是/computerPI，需要为ch5\\WEN-INF目录下的web.xml文件添加如下的子标记： ... computerPI myservlet.control.Example5_4_Servlet computerPI /computerPI ... Example5_4_Servlet类负责创建计算圆周率的近似值的servlet,所创建的servlet的成员变量被所有用户共享。Example5_4_Servlet创建的servlet的运行效果如图5.7(b)。 package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example5_4_Servlet extends HttpServlet{ double sum=0,i=1,j=1; //被所有用户共享 int number=0; //被所有用户共享 public void init(ServletConfig config) throws ServletException{ super.init(config); } public synchronized void service(HttpServletRequest request, HttpServletResponse response) throws IOException{ response.setContentType(\"text/html;charset=gb2312\"); PrintWriter out=response.getWriter(); out.println(\"\"); number++; sum=sum+i/j; j=j+2; i=-i; out.println(\"servlet:\"+getServletName()+\"已经被请求了\"+number+\"次\"); out.println(\"现在PI的值是:\"); out.println(4*sum); out.println(\"\"); } } doGet和doPost方法 ​ 可以在Servlet类中重写doPost或doGet方法来响应用户的请求，这样可以增加响应的灵活性，并降低服务器的负担。 ​ 如果不论用户请求类型是post还是get，服务器的处理过程完全相同，那么可以只在doPost方法中编写处理过程，而在doGet方法中再调用doPost方法即可，或只在doGet方法中编写处理过程，而在doPost方法中再调用doGet方法。 ​ 如果根据请求的类型进行不同的处理，就需在两个方法中编写不同的处理过程。 ​ JSP页面example5_5.jsp提供了2个表单，2个表单都请求名字为sumORproduct的servlet，并提交一串数字给所请求的servlet。效果如图5.8(a) 输入数字，用逗号分隔提交给servlet(post方式)： 输入数字，用逗号分隔提交给servlet(get方式)： ​ 名字是sumORproduct的servlet由Example5_5_Servlet类负责创建，访问它的url-pattern是/sumORproduct，需要为ch5\\WEN-INF目录下的web.xml文件添加如下的子标记： sumORproduct myservlet.control.Example5_5_Servlet sumORproduct /sumORproduct ​ Example5_5_Servlet类负责创建名字为sumORproduct的servlet。当用户的请求方式是post时，sumORproduct调用doPost方法计算数字之和，当请求方式是get时，sumORproduct调用doGet方法计算数字之乘积。Example5_5_Servlet创建的servlet的运行效果如图5.8(b)和5.8(c)。 package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example5_5_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ response.setContentType(\"text/html;charset=gb2312\"); PrintWriter out=response.getWriter(); out.println(\"\"); String s=request.getParameter(\"number\"); String []a=s.split(\"[,，]+\"); double sum = 0; for(String item:a) { if(item.length()>=1) sum+=Double.parseDouble(item); } out.print(\"用户的请求方式是\"+request.getMethod()+\"\") ; for(String item:a) { if(item.length()>=1) out.print(item+\" \"); } out.print(\"的和是\"+sum); out.println(\"\"); } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ response.setContentType(\"text/html;charset=gb2312\"); PrintWriter out=response.getWriter(); out.println(\"\"); String s=request.getParameter(\"number\"); String []a=s.split(\"[,，]+\"); double product = 1; for(String item:a) { if(item.length()>=1) product*=Double.parseDouble(item); } out.print(\"用户的请求方式是\"+request.getMethod()+\"\") ; for(String item:a) { if(item.length()>=1) out.print(item+\" \"); } out.print(\"的乘积是\"+product); out.println(\"\"); } } 重定向与转发 重定向的功能是将用户从当前页面或servlet定向到另一个JSP页面或servlet； 转发的功能是将用户对当前JSP页面或servlet的请求转发给另一个JSP页面或servlet。 sendRedirect方法 ​ void sendRedirect(String location)是HttpServletResponse类中的方法。 ​ 当用户请求一个servlet时，该servlet在处理数据后，可以使用重定向方法将用户重新定向到另一个JSP页面或servlet。重定向方法仅仅是将用户从当前页面或servlet定向到另一个JSP页面或servlet， ​ 但不能将用户对当前页面或servlet的请求（HttpServletRequest对象）转发给所定向的资源。 ​ 也就是说，重定向的目标页面或servlet无法使用request获取用户提交的数据。 RequestDispatcher对象 实现转发的步骤如下： 1．得到RequestDispatcher对象RequestDispatcher dispatcher=request.getRequestDispatcher(\"a.jsp\"); 2．转发 例如： dispatcher.forward (request,response); 将用户对当前JSP页面或servlet的请求转变成对a.jsp页面的请求。 转发的目标页面或servlet可以使用request获取用户提交的数据。 用户在浏览器的地址栏中不能看到forward方法转发的页面的地址或servlet的地址，只能看到该页面或servlet的运行效果 ​ 例子6中，用户通过exmple5_6.jsp页面提供的表单输入实数，并提交给名字为twoPath的servlet，如果用户的输入负数，那么twoPath就将用户重新定向到exmple5_6_show.jsp页面，那么exmple5_6_show.jsp 页面就无法获得用户在exmple5_6.jsp页面输入的负数。 ​ 如果用户的输入非负数，twoPath就将用户对exmple5_6.jsp页面的请求转发给example5_6_show.jsp页面，那么exmple5_6_show.jsp页面就可以获得用户在exmple5_6.jsp页面输入的非负数。exmple5_6.jsp和example5_6_show.jsp的效果如图5.9(a)和5.9(b)。 输入一个实数: 尽管example5_6.jsp它没有直接请求我 我能获得example5_6.jsp提交的非负数， 但不能获得example5_6.jsp提交的负数。 用户在example5_6.jsp输入的非负数是 ​ 名字是verify的servlet由Example5_6_Servlet类负责创建，访问它的url-pattern是/verify，需要为ch5\\WEN-INF目录下的web.xml文件添加如下的子标记： twoPath myservlet.control.Example5_6_Servlet twoPath / twoPath ​ 名字为twoPath的servlet（由Example5_6_Servlet类负责创建）. 如果用户的输入负数，那么twoPath就将用户重新定向到exmple5_6_show.jsp页面. 如果用户的输入非负数，twoPath就将用户对exmple5_6.jsp页面的请求转发给example5_6_show.jsp页面，那么example5_6_show.jsp页面就可以获得用户在example5_6.jsp页面输入的非负数。 package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example5_6_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ String number=request.getParameter(\"number\"); try{ double n=Double.parseDouble(number); if(n 使用session ​ HttpServletRequest对象request调用getSession方法获取用户的session对象： HttpSession session=request.getSession(true); ​ 例子7是一个猜字母游戏，当用户访问或刷新example5_7.jsp页面时，随机分配给用户一个a~z之间的字母，并将这个字母存在用户的session对象中。 ​ 用户链接到example5_7_input.jsp页面输入自己的猜测，并将该猜测提交给一个名字为guess的servlet. ​ 用户访问或刷新example5_7.jsp页面时，随机分配给用户一个a~z(不区分大小写)之间的字母，并将这个字母存在用户的session对象中 如果用户猜小了，将“您猜小了”存放到用户的session中,然后将用户重新定向到example5_7_input.jsp。 如果用户猜大了，将“您猜大了”存放到用户的session中，然后将用户重新定向到example5_7_input.jsp。 如果用户猜成功了，将“您猜对了”存放到用户的session中，然后将用户重新定向到example5_7_input.jsp。 ​ example5_7.jsp和example5_7_input.jsp的效果如图5.10(a),5.10(b). 访问或刷新该页面可以随机得到一个英文字母. 单击超链接去猜出这个字母:去猜字母 输入您的猜测（a~z之间的字母）: 提示信息: 单击按钮重新开始: ​ 名字是guess的servlet由Example5_7_Servlet类负责创建，访问它的url-pattern是/guess，需要为ch5\\WEN-INF目录下的web.xml文件添加如下的子标记： guess myservlet.control.Example5_7_Servlet guess / guess ​ 名字是guess的servlet由Example5_7_Servlet创建，该servlet负责处理用户的猜测，具体处理方式是：如果用户猜小了，将“您猜小了”存放到用户的session中,然后将用户重新定向到example5_7_input.jsp。如果用户猜大了，将“您猜大了”存放到用户的session中，然后将用户重新定向到example5_7_input.jsp。如果用户猜成功了，将“您猜对了”存放到用户的session中，然后将用户重新定向到example5_7_input.jsp。 Servlet类继承的service方法检查HTTP请求类型（Get 、Post等），并在service方法中根据用户的请求方式，对应地再调用doGet或doPost方法。因此，Servlet类不必重写service方法，直接继承该方法即可，可以在Servlet类中重写doPost或doGet方法来响应用户的请求。 RequestDispatcher对象可以把用户对当前JSP页面或servle的请求转发给另一个JSP页面或servlet，而且将用户对当前JSP页面或servlet的请求和响应传递给所转发的JSP页面或servlet。也就是说，当前页面所要转发的目标页面或servlet对象可以使用request获取用户提交的数据 package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example5_7_Servlet extends HttpServlet { public void init(ServletConfig config) throws ServletException { super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException { HttpSession session=request.getSession(true); //获取客户的会话对象 String str=request.getParameter(\"clientGuessLetter\"); Character guessLetter=str.trim().charAt(0); //获取客户猜测所提交的字母 //获得曾放入session中的字母： Character savedLetter=(Character)session.getAttribute(\"savedLetter\"); char realLetter=savedLetter.charValue(); if(Character.isUpperCase(guessLetter)) { guessLetter=Character.toLowerCase(guessLetter); } if(guessLetterrealLetter) { session.setAttribute(\"message\",\"您猜大了\"); response.sendRedirect(\"example5_7_input.jsp\"); } if(guessLetter==realLetter){ session.setAttribute(\"message\",\"您猜对了\"); response.sendRedirect(\"example5_7_input.jsp\"); } } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException { doPost(request,response); } } "},"page/1018.html":{"url":"page/1018.html","title":"JSP部分","keywords":"","body":"JSP部分 "},"page/1033.html":{"url":"page/1033.html","title":"标记","keywords":"","body":"标记 "},"page/1034.html":{"url":"page/1034.html","title":"指令标记","keywords":"","body":"指令标记 形式 和动作标记相比，这个指令更像描述这是怎样的文件的作用，是描述属性值 而动作更像实现功能 适应于JSP页面的指令标记 page 指令 作用 page 指令用来定义整个JSP页面的一些属性和这些属性的值 属性值用单引号或双引号括起来。 数量 可以用一个page指令指定多个属性的值 ,也可以使用多个page指令分别为每个属性指定值 . 有效性 page指令的作用对整个JSP页面有效， 与其书写的位置无关，习惯把page指令写在JSP页面的最前面。 属性 page 指令标记可以指定如下属性的值 contentType import language session buffer auotFlush isThreadSafe 或 … … language属性 作用 language属性定义JSP页面使用的脚本语言， 可取值 该属性的值目前只能取\"java\"。 默认值 JSP页面默认有如下 page指令 import属性 作用 该属性的作用是为JSP页面引入Java运行环境提供的包中的类， 这样就可以在JSP页面的程序片部分、变量及函数声明部分、表达式部分使用包中的类。 可取值 使用page指令可以为import属性指定多个值，这些值用逗号分隔。 该属性的值可以是某包中的所有类或一个具体的类。 默认值 JSP页面默认import属性已经有java.lang.*、 javax.servlet.*、javax.servlet.jsp.*、javax.servlet.http.*等值 例如: 当为import指定多个属性值时，比如： 那么，JSP引擎把JSP页面转译成的Java文件中会有如下的import语句：import java.util.*; import java.io.*; contentType属性 作用 contentType 属性值确定JSP页面响应的MIME（Multipurpose Internet Mail Extention）类型 和JSP页面字符的编码。 当用户请求一个JSP页面时，Tomcat服务器负责解释执行JSP页面，并将某些信息发送到用户的浏览器，以便用户浏览这些信息。Tomcat服务器同时负责通知用户的浏览器使用怎样的方法来处理所接收到的信息。 可取值 属性值的一般形式是“MIME类型” 或 \"MIME类型;charset=编码\" 默认值 如果不使用page指令为contentType指定一个值，那么contentType属性的默认值是 \"text/html ; charset=ISO-8859-1“ 注意 不允许两次使用page 指令给contentType属性指定不同的属性值 . ISO-8859-1不支持中文需要改成GB2312或UTF-8 例如: 用户的浏览器启用HTML解析器来解析执行所接收到的信息 用户的浏览器启用本地的MS-Word应用程序来解析执行收到的信息 使用html处理所接受到的信息。 启动MS-Word应用程序处理所接受到的信息。 session属性 作用 session 属性用于设置是否需要使用内置的session对象。 可取值 session的属性值可以是true或false。 默认值 session属性默认的属性值是true。 buffer属性 作用 内置输出流对象out负责将服务器的某些信息或运行结果发送到用户端显示。 buffer属性用来指定out设置的缓冲区的大小或不使用缓冲区。 可取值 buffer属性可以取值具体大小或者\"none\"即设置out不使用缓冲区。 默认值 buffer属性的默认值是8kb autoFlush属性 作用 autoFlush 属性指定out的缓冲区被填满时，缓冲区是否自动刷新。 可取值 autoFlush可以取值true或false。 当autoFlush属性取值false时，如果out的缓冲区填满，就会出现缓存溢出异常。 默认值 autoFlush属性的默认值是true。 注意 当buffer的值是\"none\"时，autoFlush的值就不能设置成false isThreadSafe属性 作用 isThreadSafe属性用来设置JSP页面是否可多线程访问。 可取值 isThreadSafe的属性值可取true或false。 当isThreadSafe属性值设置为true时，JSP页面能同时响应多个用户的请求； 当isThreadSafe属性值设置成false时，JSP页面同一时刻只能响应一个用户的请求，其他用户须排队等待。 默认值 isThreadSafe属性的默认值是true。 info属性 作用 其目的是为JSP页面准备一个常用且可能要经常修改的字符串。 属性值 info属性的属性值是一个字符串 可以在JSP页面中使用方法：getServletInfo();获取info属性的属性值。 当JSP页面被转译成Java文件时，转译成的类是Servlet的一个子类，所以在JSP页面中可以使用Servlet类的方法：getServletInfo()。 使用getServletInfo()方法获取info的属性值，（需要将一幅图像tsinghua.jpg存放到服务目录的image文件夹中）。 \"> 出版社是中国著名出版社 是全国著名的高等学府 适应于JSP页面和Tag文件的指令标记 include 指令 作用 对JSP文件 include指令标记的作用是在JSP页面出现该指令的位置处，静态插入一个文件. 对Tag文件 在Tag文件中也有和JSP文件类似的include指令标记，其使用方法和作用与JSP文件中的include指令标记类似。 include指令标记的作用是在Tag文件中出现该指令的位置处，静态插入一个文件。 使用include指令可以实现代码的复用。 语法格式 注意 所谓静态插入，就是当前JSP页面和插入的文件合并成一个新的JSP页面，然后JSP引擎再将这个新的JSP页面转译成Java文件。因此，插入文件后，必须保证新合并成的JSP页面符合JSP语法规则。 比如，合并后的JSP页面不能两次使用page指令为contentType属性设置不同的属性值，导致出现语法错误。 file属性 属性值 文件URL 如果该文件和当前JSP页面在同一Web服务目录中，那么文件的URL就是文件的名字； 如果该文件在JSP页面所在的Web服务目录的一个子目录中，比如fileDir子目录中，那么文件的URL就是fileDir/文件的名字。 demo.jsp 请输入一个正数,单击按钮求这个数的平方根。 computer.jsp \"+\"请输入数字字符\"); } %> taglib指令 作用 JSP文件 使用taglib指令标记引入该Web服务目录下的标记库。 Tag文件 一个Tag文件可以使用Tag标记来调用其它的Tag文件。 Tag文件必须使用taglib指令引入该Web服务目录下的标记库，才可以使用Tag标记来调用相应的Tag文件。 格式 引入标记库 数量 一个JSP页面可以使用几个taglib指令标记引入若干个标记库 注意 导入的是一个文件夹，并不是某一个具体文件 下面在jsp页面用到时，需要使用tag标记调用 相当于头文件或者函数声明 tagdir属性 可取值 需要使用标记文件所在的文件夹 从/WEB-INF相对路径开始写 prefix属性 其中前缀可以自定义取值，目的是为了区分不同路径下的相同Tag文件 JSP文件 以下是调用Tag文件的效果： 以下是调用Tag文件的效果： Tag文件 FirstTag.tag文件使用Tag标记调用SecondTag.tag文件。 SecondTag.tag文件负责从四组数中随机取出m个(m FirstTag.tag将SecondTag.tag返回的m个随机数从小到大排列，并计算出它们的和。demo.jsp使用Tag标记调用FirstTag.tag demo.jsp /WEB-INF/tags/geng/FirstTag.tag \"/> 按从小到大排列:\"); for(int i=0;i得到的\"+number+\"个随机数之和:\"+sum+\"\"); %> /WEB-INF/tags/geng/SecondTag.tag 0) { int m=(int)(Math.random()*listBox.size()); Integer integer=(Integer)listBox.get(m); listNeeded.add(integer); listBox.remove(m); count--; } jspContext.setAttribute(\"listNumber\",listNeeded); //返回listNumber %> 效果 适应于Tag文件的指令标记 Tag指令 作用 Tag文件中的tag指令类似于JSP文件中的page指令。 Tag文件通过使用tag指令可以指定某些属性的值，以便从总体上影响Tag文件的处理和表示。 语法 在一个Tag文件中可以使用多个tag指令，因此我们经常使用多个tag指令为属性指定需要的值 …… 属性 tag指令可以操作的属性有 body-content language import pageEncoding body-content属性 功能 body-content属性的值可以确定JSP页面使用Tag标记时是否可以有标记体，如果允许有标记体，该属性会给出标记体内容的类型。 可取值 body-content属性值有：empty、tagdependent、scriptless，默认值是scriptless。 属性的值是empty,JSP页面必须使用没有标记体的Tag标记来调用相应的Tag文件。 属性的值是tagdependent或scriptless,JSP页面使用无标记体或有标记体的Tag标记来调用相应的Tag文件。 属性值是scriptless,那么标记体中不能有Java程序片； 属性值是tagdependent,那么Tag文件将标记体的内容按纯文本处理。 默认值 默认值是scriptless language属性 功能 language属性的值指定Tag文件使用的脚本语言 可取值 目前只能取值java 默认值 其默认值就是java import属性 功能 import属性的作用是为Tag文件引入Java核心包中的类，这样就可以在Tag文件的程序片部分、变量及方法声明部分、表达式部分使用Java核心包中的类。 可取值 import属性可以取多个值 默认值 import属性已经有如下值： `java.lang.*`、 `javax.servlet.*`、 `javax.servlet.jsp.*`、`javax.servlet.http.*` pageEncoding属性 功能 该属性指定Tag文件的字符编码 可取值 ISO-8859-1、GB2312、UTF-8等 默认值 其默认值是ISO-8859-1 注意 默认值是ISO-8859-1不支持中文 这是一个Tab文件，负责计算1～100内的偶数之和： attribute指令 功能 在Tag文件中通过使用attribute指令，可以让使用它的JSP页面向该Tag文件传递需要的数据。 数量 可以有多个 语法 attribute指令的格式如下： 注意 attribute指令中的name属性是必需的 name属性 功能 JSP文件在调用Tag文件时，可向所调用的Tag文件中name属性指定的对象传递一个引用 可取值 名字必须符合标识符规定 即名字可以由字母、下划线、美元符号和数字组成，并且第一个字符不能是数字字符 默认值 无默认值，必须指定 注意 attribute指令中的name属性是必需的 在Tag文件中不可以再定义和attribute指令中name属性指定的对象具有相同名字的变量，否则将隐藏attribute指令中的对象，使其失效 相当于形式参数 比如，一个Tag文件MyTag.tag中有如下的attribute指令： 那么JSP页面就可以如下使用Tag标记（假设标记的前缀为computer）调用MyTag.tag： 或 我向Tag文件中传递的值是1000 type属性 功能 type指定对象的类型 可取值 带包名的对象类型 如type=\"java.util.Date\",不可简写Date 默认值 如果attribute指令中没有使用type指定对象类型，那对象类型是java.lang.String类型 注意 包名不可省 required属性 功能 可取值 true或者false true (调用改Tag文件的)JSP页面必须向该Tag文件中(attribute指令中的name属性指定的)对象传递一个引用 即如果使用，没有传递引用而调用Tag文件就会出现错误 flase (调用改Tag文件的)JSP页面可以向该Tag文件中(attribute指令中的name属性指定的)对象传递一个引用，也可以不传递 默认值 如果省略required属性，那么默认值为false demo.jsp使用Tag标记调用Triangle.tag文件，并且向Triangle.tag文件传递三角形三边的长度,Triangle.tag文件负责计算、显示三角形的面积 demo.jsp 以下是调用Tag文件的效果： /WEB-INF/tags/Triangle.tag 这是一个Tag文件，负责计算三角形的面积。 c&&a+c>b&&c+b>a) { double p=(a+b+c)/2.0; double area=Math.sqrt(p*(p-a)*(p-b)*(p-c)) ; return \"三角形的面积:\"+area; } else return(\"\"+a+\",\"+b+\",\"+c+\"不能构成一个三角形,无法计算面积\"); } %> JSP页面传递过来的三条边：\"+sideA+\",\"+sideB+\",\"+sideC); double a=Double.parseDouble(sideA); double b=Double.parseDouble(sideB); double c=Double.parseDouble(sideC); out.println(getArea(a,b,c)); %> 效果 JSP页面只负责将学生的姓名和成绩分别存放到链表（java.util.LinkedLst类型对象）中,然后将链表传递给Sort.tag，Sort.tag负责按从低到高显示学生的成绩。 demo.jsp 成绩单: \" listScore=\"\"/> /WEB-INF/tags/Sort.tag \"); out.print(\"\"); out.print(\"\"+title+\"\"); out.print(\"\"+item+\"\"); out.print(\"\"); for(int k=0;k\"); double score=(Double)listScore.get(k); String name=(String)listName.get(k); if(score\"+name+\"\"); out.print(\"\"+score+\"\"); } else{ out.print(\"\"+name+\"\"); out.print(\"\"+score+\"\"); } out.print(\"\"); } out.print(\"\"); %> 效果 variable指令 功能 Tag文件通过使用variable指令可以将Tag文件中的对象返回给调用该Tag文件的JSP页面 区别 和attribute区别 attribute直接处理就成显示html了 variable处理后是数据返回 格式 该variable指令给出的对象的名字是time、类型为java.util.Date、有效范围是AT_END。 对象的返回 jspContext调用setAttribute(“对象的名字”,对象的引用)方法存储对象的名字以及该对象的引用。 比如：jspContext.setAttribute(\"time\",new Date());将名字是time的Date对象存储到jspContext中。 以下的variable指令：为JSP页面返回名字是time的Date对象。 注意 在JSP页面中不可以再定义与Tag文件返回的对象具有相同名字的变量，否则Tag文件无法将variable给出的对象返回给JSP页面（将出现编译错误） 如果Tag文件同时使用attribute和variable指令，则两个指令中的name指定对象也不能相同 不能在Tag文件中的java程序片中直接操作variable指令对象，Tag只能将对象的名字及其引用存储到jspContext中 这一点和形式参数不一样，相当于只能声明时和最后传值时用一下，对象的引用也是最后new传过去 name-given属性 用来指定对象的名字 名字必须符合标识符规定 即名字可以由字母、下划线、美元符号和数字组成，并且第一个字符不能是数字字符 variable-class属性 作用 指定对象的类型 可选值 带包名的对象类型 如type=\"java.util.Date\",不可简写Date 默认值 如果variable指令中没有使用type指定对象类型，那对象类型是java.lang.String类型 scope属性 作用 指定对象的有效范围 可选值 AT_BEGIN (at begin) JSP页面一旦开始使用Tag标记，就可以使用variable指令给出的对象，可在该Tag标记体及该Tag标记之后使用variable指令给出的对象 NESTED (nested嵌套) 只可以在该Tag标记体中使用variable指令给出的对象 AT_END (at end) 不可以在该Tag标记前使用variable指令给出的对象 不可以在该Tag标记体中使用variable指令给出的对象 只可以在调用完该Tag标记后使用variable指令给出的对象 默认值 Tag文件GiveRoot.tag负责求出一元二次方程的根。 JSP页面在调用Tag文件时，使用attribute指令将方程的系数传递给Tag文件； Tag文件GiveRoot.tag使用variable指令返回一元二次方程的根给调用该Tag文件的JSP页面。 useOne.jsp和useTwo.jsp都使用Tag标记调用GiveRoot.tag，二者都可以得到GiveRoot.tag返回的方程的两个根，但是二者使用不同的方式来处理和显示方程的两个根。 userOne.jsp将方程的根保留最多3位小数，并计算方程的两个根之和，userTwo.jsp将方程的根保留最多5位小数，并计算方程的两个根之积。 /WEB-INF/tags/GiveRoot.tag =0&&a!=0){ root1=(-b+Math.sqrt(disk))/(2*a); root2=(-b-Math.sqrt(disk))/(2*a); jspContext.setAttribute(\"rootOne\",new Double(root1)); //为JSP页面返回对象rootOne jspContext.setAttribute(\"rootTwo\",new Double(root2)); //为JSP页面返回对象rootTwo } else{ jspContext.setAttribute(\"rootOne\",null); jspContext.setAttribute(\"rootTwo\",null); } %> userOne.jsp 方程的根保留3位小数点,并计算两个根的和: 根1:\"+s1); out.println(\"根2:\"+s2); double sum=r1+r2; out.println(\"根1与根2之和:\"+sum); } else{ out.println(\"方程没有实根\"); } %> userTwo.jsp 方程的根保留5位小数点,并计算两个根的积: 根1:\"+s1); out.println(\"根2:\"+s2); double ji=r1*r2; out.println(\"根1与根2之积:\"+ji); } else{ out.println(\"方程没有实根\"); } %> 效果 "},"page/1035.html":{"url":"page/1035.html","title":"动作标记","keywords":"","body":"动作标记 功能 动作标记是一种特殊的标记，它影响JSP运行时的功能。 格式 其实JSP页面加入tag标记和加入jsp动作标记有点像，可以不恰当理解为 中jsp是预先定义好的前缀，并且默认已经引入标记库 有点类似与系统自带函数与自定义函数的意思 适应于JSP页面的动作标记 include动作标记 作用 include动作标记告诉JSP页面动态包含一个文件，即JSP页面运行时才将文件加入。 如果包含的文件是普通的文本文件，就将文件的内容发送到用户端，由用户端的浏览器负责显示； 如果包含的文件是JSP文件，JSP引擎就执行这个文件，然后将执行的结果发送到用户端，并由用户端的浏览器负责显示这些结果。 不同 与静态插入文件的include指令标记不同。 | | include指令标记 | include动作标记 | | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | | 作用 | include指令标记的作用是在JSP页面出现该指令的位置处，静态插入一个文件. | include动作标记告诉JSP页面动态包含一个文件，即JSP页面运行时才将文件加入。 | | 加入方式 | 当前JSP页面和插入的文件合并成一个新的JSP页面，然后JSP引擎再将这个新的JSP页面转译成Java文件。加入后才是一个完整的页面 | 如果包含的文件是普通的文本文件，就将文件的内容发送到用户端，由用户端的浏览器负责显示； 如果包含的文件是JSP文件，JSP引擎就执行这个文件，然后将执行的结果发送到用户端，并由用户端的浏览器负责显示这些结果。作为附属资源加载时加入 | | 加入时间 | 首次访问时，服务器合成加入 | JSP页面运行时才将文件加入 | | 注意 | 加入后文件和加入前文件不能存在语法冲突,比如不能两次使用page指令为contentType属性设置不同的属性值 | 文本文件直接发到客户端，而JSP文件由服务器执行然后将结果发到客户端 | ​ 语法格式 或 param子标记 组合 当该标记与param标记一起使用时， 可以将param标记中的值传递到include动作标记要加载的文件中去 被加载的JSP文件可以使用Tomcat服务器提供的request内置对象获取include动作标记的param子标记中name属性所提供的值， 因此include动作标记通过使用param子标记来处理加载的文件，比include指令标记更为灵活。 demo.jsp 加载的文件 加载的图像 Myfile/car.txt one two three imageCar.html car car.jpg 效果 param 动作标记 作用 param标记以“名字—值”对的形式为其他标记提供附加信息 语法 注意 param标记不能独立使用， 需作为jsp:include、jsp:forward、jsp:plugin标记的子标记来使用。 demo.jsp使用include动作标记动态加载文件tom.jsp, 当tom.jsp文件被加载时获取demo.jsp页面中include动作标记的param子标记中name属性的值 (tom.jsp文件使用Tomcat服务器提供的request内置对象获取param子标记中name属性的值) 类似于demo.jsp调用tom.jsp并通过param传递参数 demo.jsp 加载文件效果： tom.jsp 从1到的连续和是： 效果 forward 动作标记 作用 从该指令处停止当前页面的执行，而转向执行page属性指定的JSP页面。 语法 或 param子标记 注意 当forward动作标记不需要param子标记时，必须使用第一种形式。即 当前页面使用forward动作标记转向后，尽管用户看到了转向后的页面的效果，但浏览器地址栏中显示的仍然是转向前的JSP页面的URL地址，因此，如果刷新浏览器的显示，将再次执行当前浏览器地址栏中显示的JSP页面。 组合 forward标记可以使用param动作标记作为子标记，向转向的页面传送信息。 forward动作标记指定的要转向的JSP文件可以使用Tomcat服务器提供的request内置对象获取param子标记中name属性所提供的值。 demo.jsp页面使用forward动作标记转向come.jsp页面，并向come.jsp页面传递一个数值。 demo.jsp \" /> come.jsp 您传过来的数值是: 效果 plugin动作标记 作用 该动作标记指示JSP页面加载Java plugin插件。 该插件由用户负责下载，并使用该插件来运行Java applet小程序。 语法格式 提示信息：用来提示用户的浏览器是否支持插件下载 假设有一个Java applet小程序，主类字节码文件是B.class，该文件存放在Web服务目录中，含有plugin动作标记的JSP文件demo.jsp也存放在Web服务目录中。 demo.jsp Plugin tag OBJECT or EMBED not supported by browser. useBean 动作标记 作用 该标记用来创建并使用一个Javabean Sun公司倡导的是：Javabean负责存储数据，JSP页面显示Javabean中的数据，而servlet负责管理Javabean中的数据。 适用于JSP页面和Tag文件的动作标记 tag动作标记 必须先使用taglib指令标记引入该Web服务目录下的标记库，才能使用对应标记库里面的标记 下面为在jsp文件中使用tag标记 有无标记体 不带标记体，即来调用相应的Tag文件 其中前缀为该Tag文件所在taglib的prefix属性指定 其中Tag标记为对应的Tag文件的文件名，不带.tag后缀 带标记体 标记体 ，即 标记体 当JSP页面调用一个Tag文件时可能希望动态地向该Tag文件传递信息，那么就可以使用带有标记体的Tag标记来执行一个Tag文件，Tag标记中的“标记体”就会传递给相应的Tag文件，这个Tag文件通过使用 和使用attribute区别 有无传递引用 不传递引用 不带标记体，即来调用相应的Tag文件 带标记体 标记体 ，即 标记体 传递引用 不带标记体，即来调用相应的Tag文件 其中对象名字为attribute指令中，name属性的值 使用不带标记体 demo.jsp 以下是调用Tag文件的效果： 以下是调用Tag文件的效果： /WEB-INF/tags/OddSUM.tag /WEB-INF/tags/geng/EvenSum.tag 这是一个Tab文件，负责计算1～100内的偶数之和： 效果 使用带标记体 demp.jsp页面调用Show.tag文件，而且通过标记体向Show.tag文件传递文本数据。 Show.tag文件使用处理demo.jsp页面传递过来的文本数据，将该文本数据循环显示3次并逐次增大文本字体的字号。 demo.jsp 北京奥运圆满成功! I Love this Game! 欢迎您! /WEB-INF/tags/Show.tag > 效果 适应于Tag文件的动作标记 doBody动作标记 作用 当我们使用Tag标记时，可以带有标记体，标记体还可以是一个Tag标记，这就实现了Tag标记的嵌套。 JSP页面中的Tag标记中的标记体由Tag文件的标记负责处理， 而在Tag文件中，标记被替换成对“标记体”进行处理后所得到的结果。 语法 demo.jsp页面调用Biaoge.tag,使用Tag标记嵌套显示一个表格 demo.jsp Tag标记嵌套显示学生名单: /WEB-INF/tags/Biaoge.tag \"> 效果 "},"page/1039.html":{"url":"page/1039.html","title":"资源处理(java)","keywords":"","body":"资源处理 "},"page/1040.html":{"url":"page/1040.html","title":"文件操作","keywords":"","body":"文件操作 File类 创建一个File对象的构造方法有3个： File(String filename); File(String directoryPath,String filename); File(File f, String filename); File类的下列方法获取文件本身的一些信息： public String getName() 获取文件的名字。 public boolean canRead() 判断文件是否是可读的。 public boolean canWrite() 判断文件是否可被写入。 public boolean exists() 判断文件是否存在。 public long length() 获取文件的长度（单位是字节）。 public String getAbsolutePath() 获取文件的绝对路径。 public String[] list() 用字符串形式返回目录下的全部文件. public File [] listFiles() 用File对象形式返回目录下的全部文件。 public String[] list(FilenameFilter obj) 该方法用字符串形式返回目录下的指定类型的所有文件。 public File [] listFiles(FilenameFilter obj) 该方法用File对象返回目录下的指定类型的所有文件。 ​ 例子1中，获取用户访问的当前JSP页面的一些信息。内置对象request调用getContextPath()方法获取当前Web服务目录的名称。 文件是可读的吗？ 文件的长度：字节 的父目录是: 的绝对路径是： 例子2在当前Web服务目录下创建一个名字是image的目录。 example8_2.jsp File对象调用方法 public boolean mkdir() 创建一个目录。 如果创建成功就返回true， 否则返回false （如果该目录已经存在也将返回false）。 在下创建一个新的目录：image,成功创建了吗？ image是目录吗？ 例子3（example8_3.jsp）中,列出当前Web目录下的JSP文件的名字。 在下文件： \"+file_name[i]); %> 读写文件的常用流 ​ Java的I/O流提供一条通道程序，可以使用这条通道把源中的数据送给目的地。输入流的指向称做源，程序从指向源的输入流中读取源中的数据。输出流的指向是数据要去的一个目的地，程序通过向输出流中写入数据把信息传递到目的地，如图8.2、图8.3所示。 字节输入流 ​ 如果对文件读取需求比较简单，那么可以使用FileInputStream类（文件字节输入流），该类是InputStream类的子类（以字节为单位读取文件），该类的实例方法都是从InputStream类继承来的。 使用输入流通常包括4个基本步骤： 设定输入流的源 创建指向源的输入流 让输入流读取源中的数据 关闭输入流。 构造方法 FileInputStream(String name); FileInputStream(File file); 第一个构造方法使用给定的文件名name创建FileInputStream流， 第二个构造方法使用File对象创建FileInputStream流。参数name和file指定的文件称为输入流的源。 File f = new File(\"hello.txt\"); //指定输入流的源 try { FileInputStream in = new FileInputStream(f); //创建指向源的输入流 } catch (IOException e) { System.out.println(\"File read error:\"+e ); } 使用输入流读取字节 ​ 输入流的目的是提供读取源中数据的通道，程序可以通过这个通道读取源中的数据。文件字节流可以调用从父类继承的read方法顺序地读取文件，只要不关闭流，每次调用read方法就顺序地读取文件中的其余内容，直到文件的末尾或文件字节输入流被关闭。 int read() 读取单个字节的数据，该方法返回字节值（0~255之间的一个整数），如果未读出字节就返回-1。 int read(byte b[]) 试图读取b.length个字节到字节数组b中。 int read(byte b[], int off, int len) 试图读取len个字节到字节数组b中，参数off指定从字节数组的某个位置开始存放读取的数据。 关闭流 ​ 输入流都提供了关闭方法close()，尽管程序结束时会自动关闭所有打开的流，但是当程序使用完流后，显式地关闭任何打开的流仍是一个良好的习惯。 字节输出流 ​ 如果对文件写入需求比较简单，那么可以使用FileOutputStream类（文件字节输出流），它是OutputStream类的子类（以字节为单位向文件写入内容），该类的实例方法都是从OutputStream类继承来的。 使用输出流通常包括4个基本步骤： 给出输出流的目的地 创建指向目的地的输出流 让输出流把数据写入到目的地 关闭输出流。 构造方法 FileOutputStream(String name); FileOutputStream(File file); 第一个构造方法使用给定的文件名name创建FileOutputStream流，第二个构造方法使用File对象创建FileOutputStream流。参数name和file指定的文件称为输出流的目的地。 File f=new File(\"destin.txt\"); //指定输出流的目的地 try { FileOutputStream out = new FileOutnputStream(f); //创建指向目的地的输出流 } catch (IOException e) { System.out.println(\"Filewrite:\"+e ); } 使用输出流写字节 ​ 输出流的目的是提供通往目的地的通道，程序可以通过这个通道将程序中的数据写入到目的地（如前面图10.2所示）。文件字节流可以调用从父类继承的write方法顺序地写文件。FileOutStream流顺序地向文件写入内容，即只要不关闭流，每次调用write方法就顺序地向文件写入内容，直到流被关闭。 void write(int n) 输出流调用该方法向目的地写入单个字节。 void write(byte b[]) 输出流调用该方法向目的地写入一个字节数组。 void write(byte b[],int off,int len) 给定字节数组中起始于偏移量off处取len个字节写到目的地。 关闭流 ​ 需要注意的是，在操作系统把程序所写到输出流上的那些字节保存到磁盘上之前，有时被存放在内存缓冲区中，通过调用close()方法，可以保证操作系统把流缓冲区的内容写到它的目的地，即关闭输出流可以把该流所用的缓冲区的内容冲洗掉（通常冲洗到磁盘文件上）。 字符流 ​ 与FileInputStream、FileOutputStream字节流相对应的是FileReader、FileWriter字符流（文件字符输入、输出流），FileReader和FileWriter分别是Reader和Writer的子类.字符输入流和输出流的read和write方法使用字符数组读写数据，即以字符为基本单位处理数据。 构造方法分别是： FileReader(String filename); FileReader(File filename); FileWriter (String filename); FileWriter (File filename); FileWriter (String filename,boolean append); FileWriter (File filename,boolean append); 缓冲流 BufferedReader类和BufferedWriter的构造方法分别是： BufferedReader(Reader in); BufferedWriter (Writer out); BufferedReader流能够读取文本行，方法是readLine(). BufferedReader和BufferedWriter类创建的对象称为缓冲输入、输出流，二者增强了读写文件的能力。 ​ 可以把BufferedReader和BufferedWriter称为上层流，把它们指向的字符流称为底层流。Java采用缓存技术将上层流和底层流连接。底层字符输入流首先将数据读入缓存，BufferedReader流再从缓存读取数据；BufferedWriter流将数据写入缓存，底层字符输出流会不断地将缓存中的数据写入到目的地。当BufferedWriter流调用flush()刷新缓存或调用close()方法关闭时，即使缓存没有益满，底层流也会立刻将缓存的内容写入目的地 例子4中有两个JSP页面： example8_4_choiceFile.jsp和example8_4_showFile.jsp 一个Javabean和一个servlet。 ​ 在JSP页面example8_4_choiceFile.jsp选择一个文件，提交给servlet，该servlet负责读取文件的有关信息存放到JavaBean中，并请求JSP页面example8_4_showFile.jsp显示Javanean中的数据。 ​ 需要为ch8\\WEB-INF中的web.xml文件添加如下子标记。 helpReadFile myservlet.control.Example8_4_Servlet helpReadFile /helpReadFile ​ 模型（Javabean） ​ Javabean模型Example8_4_Bean.java负责存储文件的相关信息，在本例子中Example8_4_Bean创建的Javabean模型的id是fileBean，scope取值是request。 package mybean.data; public class Example8_4_Bean { String filePath,fileName,fileContent; long fileLength; public void setFilePath(String str){ filePath=str; } public String getFilePath(){ return filePath; } public void setFileName(String str){ fileName=str; } public String getFileName(){ return fileName; } public void setFileContent(String str){ fileContent=str; } public String getFileContent(){ return fileContent; } public void setFileLength(long len){ fileLength=len; } public long getFileLength(){ return fileLength; } } 视图（JSP页面） ​ 在 example8_4_choiceFile.jsp页面可以输入文件的路径和名字，并提交给名字为handleFile的servlet对象。servlet对象负责读取文件，并将读取的内容以及相关的数据存储到id为fileBean的Javabean数据模型中，然后请求example8_4_showFile.jsp页面显示数据模型中的数据。example8_4_choiceFile.jsp和example8_4_showFile.jsp的效果如图8.4(a)和8.4(b)所示。 输入文件的路径(如:d:/2000): 输入文件的名字(如:Hello.java): 文件的位置: , 文件的名字：, 文件的长度： 字节。 文件的内容： 控制器（servlet） Example8_4_Sevlet负责读取文件的内容，将结果存放到id是fileBean的Javabean数据模型中，然后用转发的方法请求example8_4_showFile.jsp显示fileBean中的数据。 package myservlet.control; import mybean.data.Example8_4_Bean; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example8_4_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Example8_4_Bean fileBean=new Example8_4_Bean(); //创建Javabean对象 request.setAttribute(\"fileBean\",fileBean); String filePath=request.getParameter(\"filePath\"); String fileName=request.getParameter(\"fileName\"); fileBean.setFilePath(filePath); //将数据存储在fileBean中 fileBean.setFileName(fileName); try{ File f=new File(filePath,fileName); long length=f.length(); fileBean.setFileLength(length); FileReader in=new FileReader(f) ; BufferedReader inTwo=new BufferedReader(in); StringBuffer stringbuffer=new StringBuffer(); String s=null; while ((s=inTwo.readLine())!=null) stringbuffer.append(\"\\n\"+s); String content=new String(stringbuffer); fileBean.setFileContent(content); } catch(IOException exp){ fileBean.setFileContent(\"读取失败\"+exp.toString()); } RequestDispatcher dispatcher= request.getRequestDispatcher(\"example8_4_showFile.jsp\"); dispatcher.forward(request, response); } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException,IOException{ doPost(request,response); } } RandomAccessFile类 RandomAccessFile类创建的流与前面的输入、输出流不同。RandomAccessFile类既不是输入流类InputStream类的子类，也不是输出流类Outputstream类的子类。习惯上，仍然称RandomAccessFile类创建的对象为一个流。RandomAccessFile流的指向既可以作为源也可以作为目的地。换句话说，当想对一个文件进行读写操作时，可以创建一个指向该文件的RandomAccessFile流，这样既可以从这个流读取文件的数据，也可以通过这个流向文件写入数据。 RandomAccessFile类的两个构造方法： RandomAccessFile(String name,String mode) 参数name用来确定一个文件名，给出创建的流的源（也是流的目的地）。参数mode取“r”（只读）或“rw”（可读写），决定创建的流对文件的访问权利。 RandomAccessFile(File file,String mode) 参数file是一个File对象，给出创建的流的源（也是流的目的地）。参数mode取“r”（只读）或“rw”（可读写），决定创建的流对文件的访问权利。 RandomAccessFile类的读写方法 readLine() 从文件中读取一个文本行 readUTF() 从文件中读取一个UTF字符串 seek(long a) 定位当前流在文件中的读写的位置 write(byte b[]) 写b.length个字节到文件 writeDouble(double v) 向文件写入一个双精度浮点值 writeInt(int v) 向文件写入一个int值 writeUTF(String s) 写入一个UTF字符串 getFilePointer() 获取当前流在文件中的读写的位置 文件上传 用户通过一个JSP页面上传文件给服务器时，该JSP页面必须含有File类型的表单，并且表单必须将ENCTYPE的属性值设成multipart/form-data。 ​ 例子5中，用户通过example8_5.jsp页面选择的文本文件A.txt准备上传 A.txt: request获得一个输入流读取用户上传的全部信息，包括表单的头信息以及上传文件的内容。以后将讨论如何去掉表单的信息，获取文件的内容。 ​ 例子5中在example8_5_accept.jsp页面，内置对象request调用方法getInputStream()获得一个输入流in，用FileOutputStream类再创建一个输出流o。输入流in读取用户上传的信息，输出流o将读取的信息写入文件B.txt。上传后的文件是B.txt(如图8.5)。 选择要上传的文件： ​ 例子6中，通过输入、输出流技术获取文件的内容，即去掉表单的信息。 不同用户的session对象互不相同这一特点，将用户提交的全部信息首先保存成一个临时文件，该临时文件的名字是用户的session对象的id. 然后读取该临时文件的第2行，因为这一行中含有用户上传的文件的名字，再获取第4行结束的位置，以及倒数第6行结束的位置，因为这两个位置之间的内容是上传文件的内容，然后将这部分内容存入文件，该文件的名字和用户上传的文件的名字保持一致 最后删除临时文件。 需要为ch8\\WEB-INF中的web.xml文件添加如下子标记。 upFile myservlet.control.Example8_6_Servlet upFile /upFile ​ 模型（Javabean） ​ Javabean模型Example8_6_Bean.java负责存储文件的相关信息，在本例子中Example8_6_Bean创建的Javabean模型的id是fileBean，scope取值是request。 package myservlet.control; import mybean.data.Example8_6_Bean; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example8_6_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ request.setCharacterEncoding(\"gb2312\"); Example8_6_Bean fileBean=new Example8_6_Bean(); //创建Javabean对象 request.setAttribute(\"fileBean\",fileBean); String fileName=null; HttpSession session=request.getSession(true); try{ //用客户的session对象的Id建立一个临时文件 String tempFileName=(String)session.getId(); String webDir = request.getContextPath(); webDir = webDir.substring(1); File f= new File(\"\"); String path = f.getAbsolutePath(); int index = path.indexOf(\"bin\"); String tomcatDir = path.substring(0,index);//tomcat的安装目录 File dir=new File(tomcatDir+\"/webapps/\"+webDir+\"/image\"); dir.mkdir(); //建立临时文件f1 File f1=new File(dir,tempFileName); FileOutputStream o=new FileOutputStream(f1); //将客户上传的全部信息存入f1 InputStream in=request.getInputStream(); byte b[]=new byte[10000]; int n; while( (n=in.read(b))!=-1){ o.write(b,0,n); } o.close(); in.close(); //读取临时文件f1，从中获取上传文件的名字和上传文件的内容 RandomAccessFile randomRead=new RandomAccessFile(f1,\"r\"); //读出f1的第2行，析取出上传文件的名字 int second=1; String secondLine=null; while(second=0)&&(j 视图（JSP页面） example8_6.jsp页面负责提交上传文件给名字是upFile的servlet，并负责显示Javabean模型中的数据，如果Javabean模型中存放的文件不是图像文件就显示文件的名字，如果是图像文件，不仅显示文件的名字，同时也显示当前图像。example8_6.jsp效果如图8.6。 选择要上传的文件： 上传的文件名字： 上传反馈： \" width=200 height =200> 控制器（servlet） Example8_6_Sevlet负责将用户提交的文件保存到服务器端，并将文件的有关信息存放到id是fileBean的Javabean数据模型中，然后用转发的方法请求example8_6.jsp显示fileBean中的数据。 package myservlet.control; import mybean.data.Example8_6_Bean; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example8_6_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ request.setCharacterEncoding(\"gb2312\"); Example8_6_Bean fileBean=new Example8_6_Bean(); //创建Javabean对象 request.setAttribute(\"fileBean\",fileBean); String fileName=null; HttpSession session=request.getSession(true); try{ //用客户的session对象的Id建立一个临时文件 String tempFileName=(String)session.getId(); String webDir = request.getContextPath(); webDir = webDir.substring(1); File f= new File(\"\"); String path = f.getAbsolutePath(); int index = path.indexOf(\"bin\"); String tomcatDir = path.substring(0,index);//tomcat的安装目录 File dir=new File(tomcatDir+\"/webapps/\"+webDir+\"/image\"); dir.mkdir(); //建立临时文件f1 File f1=new File(dir,tempFileName); FileOutputStream o=new FileOutputStream(f1); //将客户上传的全部信息存入f1 InputStream in=request.getInputStream(); byte b[]=new byte[10000]; int n; while( (n=in.read(b))!=-1){ o.write(b,0,n); } o.close(); in.close(); //读取临时文件f1，从中获取上传文件的名字和上传文件的内容 RandomAccessFile randomRead=new RandomAccessFile(f1,\"r\"); //读出f1的第2行，析取出上传文件的名字 int second=1; String secondLine=null; while(second=0)&&(j 文件下载 ​ JSP内置对象response调用方法getOutputStream()可以获取一个指向用户的输出流，服务器将文件写入这个流，用户就可以下载这个文件了。当提供下载功能时，应当使用response对象向用户发送HTTP头信息，这样用户的浏览器就会调用相应的外部程序打开下载的文件，response调用setHeader方法添加下载头的格式如下： response.setHeader(\"Content-disposition\",\"attachment;filename=\"下载文件名\"); ​ 例子7中，用户在example8_7.jsp页面选择一个要下载的文件，将该文件的名字提交给名字是loadFile的servlet(Example8_7_Sevlet负责创建servlet)，servlet将用户选择的文件发送给用户，即提供下载。example8_7.jsp，loadFile的效果如图8.7(a)和8.7(b)。 需要为ch8\\WEB-INF中的web.xml文件添加如下子标记。 loadFile myservlet.control.Example8_7_Servlet loadFile /loadFile > 视图（JSP页面） ​ 用户在example8_7.jsp页面选择一个要下载的文件，将该文件的名字提交给名字是loadFile的servlet(Example8_7_Sevlet负责创建servlet)。效果如图8.7(a). 选择要下载的文件： E.java first.jsp book.zip A.txt 控制器（servlet） Example8_7_Sevlet负责创建servlet)，servlet将用户选择的文件发送给用户，即提供下载。loadFile的效果如图8.7(b)。 package myservlet.control; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example8_7_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ request.setCharacterEncoding(\"gb2312\"); String filePath=request.getParameter(\"filePath\"); String fileName=filePath.substring(filePath.lastIndexOf(\"/\")+1); response.setHeader(\"Content-disposition\",\"attachment;filename=\"+fileName); try{ //读取文件,并发送给用户下载: File f=new File(filePath); FileInputStream in=new FileInputStream(f); OutputStream out=response.getOutputStream(); int n=0; byte b[]=new byte[500]; while((n=in.read(b))!=-1) out.write(b,0,n); out.close(); in.close(); } catch(Exception exp){ } } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException,IOException{ doPost(request,response); } } 输入流的指向称为源，程序从指向源的输入流中读取源中的数据。而输出流的指向是数据要去的目的地，程序通过向输出流中写入数据把信息送往目的地。 FileInputStream和FileReader流都顺序地读取文件，只要不关闭流，每次调用read方法就顺序地读取源中其余的内容，直到源的末尾或流被关闭。二者的区别是，FileInputStream流以字节（byte）为单位读取文件；FileReader流以字符（char）为单位读取文件。 FileOutStream流和FileWriter 顺序地写文件，只要不关闭流，每次调用writer方法就顺序地向输出流写入内容，直到流被关闭。二者的区别是，FileOutStream流以字节（byte）为单位写文件；FileWriter流以字符（char）为单位写文件。 RandomAccessFile流的指向既可以作为源也可以作为目的地，在读写文件时可以调用seek方法改变读写位置。 "},"page/1041.html":{"url":"page/1041.html","title":"数据库","keywords":"","body":"数据库 连接mysql 加载JDBC-数据库驱动程序 下载mysql-connector-java-5.1.28.zip，将该zip文件解压至硬盘，在解压后的目录下的mysql-connector-java-5.1.28-bin.jar文件就是连接MySQL数据库的JDBC-数据库驱动程序。 将该驱动程序复制到Tomcat服务器所使用的JDK的扩展目录中（即java_home环境变量指定的JDK），比如：D:\\jdk1.7\\jre\\lib\\ext 或复制到Tomcat服务器安装目录的\\common\\lib文件夹中，比如：D:\\apache-tomcat-8.0.3\\common\\lib 加载MySQL的JDBC-数据库驱动程序代码如下： try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} 建立连接 ​ 为了能和MySQL数据库服务器管理的数据库建立连接，必须保证该MySQL数据库服务器已经启动，如果没有更改过MySQL数据库服务器的配置，那么该数据库服务器占用的端口是3306。假设MySQL数据库服务器所驻留的计算机的IP地址是192.168.100.1 使用Connection getConnection(String,String,String)方法建立连接的代码如下： try{ String uri = \"jdbc:mysql:// 192.168.100.1:3306/warehouse\"; String user =\"root\"; String password =\"99\"; con = DriverManager.getConnection(uri,user,password); } catch(SQLException e){ System.out.println(e); } 使用Connection getConnection(String)方法建立连接的代码如下： try{ String uri = \" jdbc:mysql://192.168.100.1:3306/warehouse?user=root&password=99\"; con = DriverManager.getConnection(uri); } catch(SQLException e){ System.out.println(e); } //如果root用户没有设置密码，那么将上述uri中的 &password=99更改为：&password= 解决乱码 用户要和连接MySQL驻留在同一计算机上，使用的IP地址可以是127.0.0.1或localhost。另外，由于3306是MySQL数据库服务器的默认端口号，链接数据库时允许应用程序省略默认的3360端口号. 数据库和表使用支持中文的字符编码 在创建数据库时指定数据库使用的字符编码： create 数据库名 CHARACTER SET字符编码 创建表时，可以指定某个字段使用的字符编码： 字段名 类型 CHARACTER SET字符编码 create people CHARACTER SET gb2312 create table myList ( id int, name varchar(100) CHARACTER SET gb2312, PRIMARY KEY (id) ); 连接数据库支持中文编码，避免操作数据库出现中文乱码 JSP中连接MySQL数据库时，需要使用 Connection getConnection(java.lang.String) 方法建立连接，而且向该方法参数传递的字符串是： “jdbc:mysql://地址/数据库?user=用户&password=密码 &characterEncoding=gb2312\"; 使用Connection getConnection(String)方法建立连接，连接代码是（假设用户是root，其密码是99）： String uri = \"jdbc:mysql://127.0.0.1/warehouse?\"+\"user=root&password=99&characterEncoding=gb2312\"; ​ 例子1是一个简单的JSP页面，该页面中的Java程序片代码负责加载JDBC-驱动程序，并连接到数据库warehouse，查询product表中全部记录(见7.1节曾建立的warehouse数据库)，页面运行效果如图7.18。 \"); out.print(\"\"); out.print(\"\"+\"产品号\"); out.print(\"\"+\"名称\"); out.print(\"\"+\"生产日期\"); out.print(\"\"+\"价格\"); out.print(\"\"); while(rs.next()){ out.print(\"\"); out.print(\"\"+rs.getString(1)+\"\"); out.print(\"\"+rs.getString(2)+\"\"); out.print(\"\"+rs.getDate(\"madeTime\")+\"\"); out.print(\"\"+rs.getFloat(\"price\")+\"\"); out.print(\"\") ; } out.print(\"\"); con.close(); } catch(SQLException e){ out.print(e); } %> 查询记录 ​ 和数据库建立连接后，就可以使用JDBC提供的API和数据库交互信息。比如查询、修改和更新数据库中的表等。 ​ JDBC和数据库表进行交互的主要方式是使用SQL语句，JDBC提供的API可以将标准的SQL语句发送给数据库，实现和数据库的交互。 结果集与查询 1．SQL查询语句与结果集 让连接对象con调用方法createStatement()创建这个SQL语句对象： try{ Statement sql=con.createStatement(); } catch(SQLException e ){ System.out.println(e); } 对于 ResultSet rs=sql.executeQuery(\"SELECT * FROM product\"); 内存的结果集对象rs的列数是4列，刚好和product的列数相同. 对于 ResultSet rs= sql.executeQuery(\"SELECT name,price FROM product\"); 内存的结果集对象rs只有两列，第1列是name列、第2列是price列。 ResultSet结果集一次只能看到一个数据行，使用next()方法走到下一数据行，获得一行数据后，ResultSet结果集可以使用getXxx方法获得字段值(列值)，将位置索引（第一列使用1，第二列使用2等等）或列名传递给getXxx方法的参数即可 2．结果集的列名与列的数目 ​ 程序查询的时候。为了代码更加容易维护，希望知道数据库表的字段（列）的名字以及表的字段的个数，那么一个办法是使用返回到程序中的结果集来获取相关的信息。 假如结果集是rs (1) 得到元数据对象metaData ResultSetMetaData metaData = rs.getMetaData(); (2)得到结果集的列的个数，即共有几列 int columnCount = metaData.getColumnCount(); (3)结果集rs中的第i列的名字： String columnName = metaData.getColumnName(i); 随机查询 使用下述方法获得一个Statement对象： Statement stmt=con.createStatement(int type,int concurrency); type取值： ResultSet.TYPE_SCROLL_INSENSITIVE 或 ResultSet.TYPE_SCROLL_SENSITIVE Concurrency取值： ResultSet.CONCUR_READ_ONLY 或 ResultSet.CONCUR_UPDATABLE 根据参数的type、concurrency的取值情况，stmt返回相应类型的结果集：ResultSet re=stmt.executeQuery(SQL语句); 滚动查询经常用到ResultSet的下述方法： public void first()：将游标移到结果集的第一行。 public void last()：将游标移到结果集的最后一行。 public int getRow()：得到当前游标所指行的行号，行号从1开始，如果结果集没有行，返回0 public boolean absolute(int row)：将游标移到参数row指定的行号。 条件查询 \"select… from 表 where 字段 满足的条件\" 例如： \"select * from product where price > 2000 and price 使用MVC模式显示warehouse数据库product表中price字段值大于某个值的记录。 ​ 根据例子2中使用的servlet的名字及相关类，Web服务目录ch7的WEB-INF下的web.xml文件需包含如下内容。 queryByConditionServlet myservlet.control.Example7_2_Servlet queryByConditionServlet /queryByConditionServlet ​ 模型（Javabean） Javabean模型Example7_2_Bean.java负责存储查询到的记录，在本例子中Example7_2_Bean创建的Javabean模型的id是resultBean，scope取值是request。 package mybean.data; public class Example7_2_Bean{ String []columnName ; //存放列名 String [][] tableRecord=null; //存放查询到的记录 public Example7_2_Bean() { tableRecord = new String[1][1]; columnName = new String[1]; } public void setTableRecord(String [][] s){ tableRecord=s; } public String [][] getTableRecord(){ return tableRecord; } public void setColumnName(String [] s) { columnName = s; } public String [] getColumnName() { return columnName; } } 视图（JSP页面） 视图部分由2个JSP页面构成，其中example7_2.jsp页面负责提供输入数据的视图，即用户可以在该页面输入查询的价格条件，然后将数据提交给名字是queryByConditionServlet的servlet。queryByConditionServlet负责查询数据库，并将结果存储到id为resultBean的Javabean数据模型中，然后请求视图中的showRecord.jsp显示数据模型resultBean中的数据。 example7_2.jsp和showRecord.jsp的效果如图7.19(a)和图7.19(b)所示 查询warehouse数据库product表中 price值大于的记录 输入用户名：(默认root) 输入密码： (默认空) 控制器（servlet） Example7_2_Sevlet负责创建名字是 queryByConditionServlet的servlet（见例子2前面web.xml文件的有关内容）。 queryByConditionServlet查询warehouse数据库的product表中满足价格条件的记录，将结果存放到id是resultBean的Javabean数据模型中， 然后用转发的方法请求showRecord.jsp显示resultBean中的数据。 package myservlet.control; import mybean.data.Example7_2_Bean; import java.io.*; import java.sql.*; import javax.servlet.*; import javax.servlet.http.*; public class Example7_2_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Example7_2_Bean resultBean=null; try{ resultBean=(Example7_2_Bean)request.getAttribute(\"resultBean\"); if(resultBean==null){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } } catch(Exception exp){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} String number = request.getParameter(\"price\"); if(number==null||number.length()==0) return; String dataBase = request.getParameter(\"dataBase\"); String tableName = request.getParameter(\"tableName\"); String user = request.getParameter(\"user\"); String password = request.getParameter(\"password\"); float p = Float.parseFloat(number); Connection con; Statement sql; ResultSet rs; try{ String uri=\"jdbc:mysql://127.0.0.1/\"+dataBase; con=DriverManager.getConnection(uri,user,password); sql=con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY); String condition =\"SELECT * FROM \"+tableName+\" where price > \"+p; rs=sql.executeQuery(condition); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); //得到结果集的列数 String []columnName = new String[columnCount]; for(int i=0;i 更新、添加与删除记录 1．更新 Statement对象调用方法： public int executeUpdate（String sqlStatement）; 实现对数据库表中记录的字段值的更新。例如， executeUpdate(\"UPDATE product SET price = 6866 WHERE name='海尔电视机'\"); 2．添加 Statement对象调用方法： public int executeUpdate（String sqlStatement）; 实现向数据库表中添加新的记录。例如， executeUpdate(\"INSERT INTO students VALUES ('012','神通手机’,'2015-2-26',2687)\"); 3．删除 Statement对象调用方法： public int executeUpdate（String sqlStatement）; 删除数据库表中的记录。例如： executeUpdate(\"DELETE FROM product WHERE number = '888' \"); 下面的例子3使用MVC模式（有关知识见第6章）向warehouse数据库product表中插入。 ​ 根据例子3中使用的servlet的名字及相关类，Web服务目录ch7的WEB-INF下的web.xml文件需包含如下内容： insertServlet myservlet.control.Example7_3_Servlet insertServlet /insertServlet ​ 模型（Javabean） ​ Javabean模型例子2中的Example7_2_Bean.java完全相同，创建的Javabean模型的id是resultBean，scope取值是request。 ch7/WEB-INF/classes/mybean/data/Example7_2_Bean.java package mybean.data; public class Example7_2_Bean{ String []columnName ; //存放列名 String [][] tableRecord=null; //存放查询到的记录 public Example7_2_Bean() { tableRecord = new String[1][1]; columnName = new String[1]; } public void setTableRecord(String [][] s){ tableRecord=s; } public String [][] getTableRecord(){ return tableRecord; } public void setColumnName(String [] s) { columnName = s; } public String [] getColumnName() { return columnName; } } 视图（JSP页面） 视图部分由2个JSP页面构成，一个是example7_3.jsp，另一个是例子2中的showRecord.jsp，其中example7_3.jsp页面负责提供输入新记录提交给名字是insertServlet的servlet。 insertServlet负责将记录插入到数据库的表中，然后查询数据库的表，并将查询结果存储到id为resultBean的Javabean数据模型中，然后请求视图中的showRecor.jsp显示数据模型resultBean中的数据。example7_3.jsp和showRecord.jsp的效果如图7.20(a)和图7.20(b)所示。 为了避免出现中文乱码，数据库的连接方式采用： “jdbc:mysql://地址/数据库?user=用户&password=密码 &characterEncoding=gb2312\"; package myservlet.control; import mybean.data.Example7_2_Bean; //引入例子2中的Javabean模型 import java.io.*; import java.sql.*; import javax.servlet.*; import javax.servlet.http.*; public class Example7_3_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Example7_2_Bean resultBean=null; try{ resultBean=(Example7_2_Bean)request.getAttribute(\"resultBean\"); if(resultBean==null){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } } catch(Exception exp){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} request.setCharacterEncoding(\"gb2312\"); String dataBase = request.getParameter(\"dataBase\"); String tableName = request.getParameter(\"tableName\"); String nu=request.getParameter(\"number\"); String na=request.getParameter(\"name\"); String mT=request.getParameter(\"madeTime\"); String pr=request.getParameter(\"price\"); if(nu==null||nu.length()==0) { fail(request,response,\"添加记录失败,必须给出记录\"); return; } float p=Float.parseFloat(pr); String condition = \"INSERT INTO \"+tableName+\" VALUES\"+ \"(\"+\"'\"+nu+\"','\"+na+\"','\"+mT+\"',\"+p+\")\"; Connection con; Statement sql; ResultSet rs; try{ String uri=\"jdbc:mysql://127.0.0.1/\"+dataBase+\"?\"+ \"user=root&password=&characterEncoding=gb2312\"; con=DriverManager.getConnection(uri); sql=con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY); sql.executeUpdate(condition); rs=sql.executeQuery(\"SELECT * FROM \"+tableName); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); //得到结果集的列数 String []columnName = new String[columnCount]; for(int i=0;i\"); out.println(\"\"+backNews+\"\") ; out.println(\"返回\"); out.println(\"输入记录\"); out.println(\"\"); } catch(IOException exp){} } } 用结果集操作数据库中的表 ​ 尽管可以用SQL语句对数据库中表进行更新、插入操作，但也可以使用内存中ResultSet结果集对底层数据库表进行更新和插入操作（这些操作由系统自动转化为相应的SQL语句），优点是不必熟悉有关更新、插入的SQL语句，而且方便编写代码，缺点是，必须要事先返回结果集。 更新记录 使用结果集更新数据库表中第n行记录中某列的值的步骤是： 1.结果集rs的游标移动到第n行 rs.absolute(n); 2.结果集将第n行的某列的列值更新 例如 更新列名是columnName的日期值是x指定的值： updateDate(String columnName, Date x) 3.更新数据库中的表 最后，结果集调用updateRow()方法用结果集中的第n行更新数据库表中的第n行记录。 以下代码片段更新product表中的第3行记录的name列（字段）的值。 rs.absolute(3); rs.updateString(\"name\", \"IBM PC\"); rs.updateRow(); 插入记录 使用结果集向数据库表中插入（添加）一行记录步骤是： 1.结果集rs的游标移动到插入行 rs.moveToInsertRow(); 2.更新插入行的列值 例如： rs.updateString(1, \"c002\"); rs.updateString(2, \"IBM iPad\"); rs.updateDate(3,Date()); rs.updateDouble(4, 5356); 3.插入记录 最后，结果集调用insertRow()方法用结果集中的插入行向数据库表中插入一行新记录。 下面的例子4使用MVC模式向warehouse数据库product表中插入录，但和前面的例子3不同的是，例子4不直接使用SQL语句，而是使用结果集操作数据库中的表。 根据例子4中使用的servlet的名字及相关类，Web服务目录ch7的WEB-INF下的web.xml文件需包含如下内容 insertBySetServlet myservlet.control.Example7_4_Servlet insertBySetServlet /insertBySetServlet ​ 模型（Javabean） ​ Javabean模型与例子2中的Example7_2_Bean.java完全相同，创建的Javabean模型的id是resultBean，scope取值是request。 视图（JSP页面） 视图部分由2个JSP页面构成，一个是example7_4.jsp，另一个是例子2中的showRecord.jsp。 其中example7_4.jsp页面负责提供输入新记录的视图，即用户可以在该页面输入要添加的记录，然后将要添加的记录提交给名字是insertBySetServlet的servlet。 insertBySetServlet负责将记录插入到数据库的表中，然后查询数据库的表，并将查询结果存储到id为resultBean的Javabean数据模型中，然后请求视图中的showRecor.jsp显示数据模型resultBean中的数据。example7_4.jsp和showRecord.jsp的效果如图7.21(a)和图7.21(b)所示。 添加新记录: 产品号： 名称： 生产日期(日期必须用-或/格式)： 价格： 控制器（servlet） Example7_4_Sevlet负责创建名字是insertBySetServlet的servlet（见例子4前面web.xml文件的有关内容）。insertBySetServlet使用结果集操作数据库，并向数据库warehouse的product表插入记录，然后查询product表中的全部记录，将结果存放到id是resultBean的Javabean数据模型中，然后用转发的方法请求showRecod.jsp显示resultBean中的数据. ​ 为了避免出现中文乱码，数据库的连接方式采用： \"jdbc:mysql://地址/数据库?user=用户&password=密码 &characterEncoding=gb2312\"; package myservlet.control; import mybean.data.Example7_2_Bean; //引入例子2中的Javabean模型 import java.io.*; import java.sql.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.Calendar; public class Example7_4_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Example7_2_Bean resultBean=null; try{ resultBean=(Example7_2_Bean)request.getAttribute(\"resultBean\"); if(resultBean==null){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } } catch(Exception exp){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} request.setCharacterEncoding(\"gb2312\"); String dataBase = request.getParameter(\"dataBase\"); String tableName = request.getParameter(\"tableName\"); String number=request.getParameter(\"number\"); String name=request.getParameter(\"name\"); String madeTime=request.getParameter(\"madeTime\"); String pr=request.getParameter(\"price\"); if(number==null||number.length()==0) { fail(request,response,\"添加记录失败,必须给出记录\"); return; } float price=Float.parseFloat(pr); Connection con; Statement sql; ResultSet rs; try{ String uri=\"jdbc:mysql://127.0.0.1/\"+dataBase+\"?\"+ \"user=root&password=&characterEncoding=gb2312\"; con=DriverManager.getConnection(uri); sql=con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY); rs=sql.executeQuery(\"SELECT * FROM \"+tableName); rs.moveToInsertRow(); //rs的游标移动到插入行 rs.updateString(1,number); //更新结果集 rs.updateString(2, name); //更新结果集 String [] str=madeTime.split(\"[-/]\");//输入的日期必须用-或/格式 int year=Integer.parseInt(str[0]); int month=Integer.parseInt(str[1]); int day=Integer.parseInt(str[2]); Calendar calendar =Calendar.getInstance(); calendar.set(year,month-1,day); Date date=new java.sql.Date(calendar.getTimeInMillis()); rs.updateDate(3,date); //更新结果集 rs.updateDouble(4,price); //更新结果集 rs.insertRow(); //向表插入一行记录 rs=sql.executeQuery(\"SELECT * FROM \"+tableName); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); //得到结果集的列数 String []columnName = new String[columnCount]; for(int i=0;i\"); out.println(\"\"+backNews+\"\") ; out.println(\"返回\"); out.println(\"输入记录\"); out.println(\"\"); } catch(IOException exp){} } } 预处理语句 ​ Java提供了更高效率的数据库操作机制，就是PreparedStatement对象，该对象被习惯地称作预处理语句对象。本节学习怎样使用预处理语句对象操作数据库中的表。 预处理语句优点 Connection连接对象con调用prepareStatement(String sql)方法： PreparedStatement pre=con.prepareStatement(String sql); 对参数sql指定的SQL语句进行预编译处理. 那么pre调用下列方法都可以使得该底层内部命令被数据库执行： ResultSet executeQuery() boolean execute() int executeUpdate() ​ 只要编译好了PreparedStatement对象pre，那么pre可以随时地执行上述方法，提高了访问数据库的速度。 在下面的例5使用预处理语句来查询warehouse数据库中product表的全部记录 \"); out.print(\"\"); out.print(\"\"+\"产品号\"); out.print(\"\"+\"名称\"); out.print(\"\"+\"生产日期\"); out.print(\"\"+\"价格\"); out.print(\"\"); while(rs.next()){ out.print(\"\"); out.print(\"\"+rs.getString(1)+\"\"); out.print(\"\"+rs.getString(2)+\"\"); out.print(\"\"+rs.getDate(\"madeTime\")+\"\"); out.print(\"\"+rs.getFloat(\"price\")+\"\"); out.print(\"\") ; } out.print(\"\"); con.close(); } catch(SQLException e){ out.print(e); } %> 使用通配符 在对SQL进行预处理时可以使用通配符“？”来代替字段的值。例如： prepareStatement pre=con.prepareStatement(\"SELECT * FROM product WHERE price 先调用相应的方法设置通配符“？”代表的具体值，比如： pre.setDouble(1,6565); 指定上述预处理语句pre中第1个通配符“？”代表的值是6565。 ​ 通配符按着它们在预处理的“SQL语句”中从左至右依次出现的顺序分别被称做第1个、第2个… 第m个通配符。 预处理语句设置通配符“？”的值的常用方法有： void setDate(int parameterIndex,Date x) void setDouble(int parameterIndex,double x) void setFloat(int parameterIndex,float x) 例子6使用MVC模式更新warehouse数据库product表中的记录，但和前面的例子不同的是，这里使用了预处理语句。 根据例子6中使用的servlet的名字及相关类，Web服务目录ch7的WEB-INF下的web.xml文件需包含如下内容 preparedServlet myservlet.control.Example7_6_Servlet preparedServlet /preparedServlet ​ 模型（Javabean） ​ Javabean模型与例子2中的Example7_2_Bean.java完全相同，创建的Javabean模型的id是resultBean，scope取值是request。 视图（JSP页面） 视图部分由2个JSP页面构成，一个是example7_6.jsp，另一个是例子2中的showRecord.jsp(showRecod.jsp的代码见例子2的视图部分)。example7_6.jsp页面将要更新的记录，提交给名字是preparedServlet的servlet。preparedServlet负责更新数据库表中的记录，然后查询数据库的表，并将查询结果存储到id为resultBean的Javabean数据模型中，然后请求视图中的showRecord.jsp（见例子2中的视图部分）显示数据模型resultBean中的数据。example7_6.jsp和showRecord.jsp的效果如图7.22(a)和图7.22(b)所示 输入主键number是 的name,madeTime和price的更新值： name: madeTime: price: 控制器（servlet） Example7_6_Servlet负责创建名字是insertServlet的servlet（见例子3前面web.xml文件的有关内容）。insertServlet负责向数据库warehouse的product表插入记录，并查询product表中的全部记录，将结果存放到id是resultBean的Javabean数据模型中，然后用转发的方法请求showRecod.jsp显示resultBean中的数据。 为了避免出现中文乱码，数据库的连接方式采用： “jdbc:mysql://地址/数据库?user=用户&password=密码 &characterEncoding=gb2312\"; package myservlet.control; import mybean.data.Example7_2_Bean; //引入例子2中的Javabean模型 import java.io.*; import java.sql.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.Calendar; public class Example7_6_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Example7_2_Bean resultBean=null; try{ resultBean=(Example7_2_Bean)request.getAttribute(\"resultBean\"); if(resultBean==null){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } } catch(Exception exp){ resultBean=new Example7_2_Bean(); //创建Javabean对象 request.setAttribute(\"resultBean\",resultBean); } try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} request.setCharacterEncoding(\"gb2312\"); String number=request.getParameter(\"number\"); String name=request.getParameter(\"name\"); String madeTime=request.getParameter(\"madeTime\"); String pr=request.getParameter(\"price\"); if(number==null||number.length()==0) { fail(request,response,\"更新记录失败,必须给出记录\"); return; } float price=Float.parseFloat(pr); String [] str=madeTime.split(\"[-/]\");//输入的日期必须用-或/格式 int year=Integer.parseInt(str[0]); int month=Integer.parseInt(str[1]); int day=Integer.parseInt(str[2]); Calendar calendar =Calendar.getInstance(); calendar.set(year,month-1,day); Date date=new Date(calendar.getTimeInMillis()); Connection con; PreparedStatement sql; //预处理语句 ; ResultSet rs; try{ String uri=\"jdbc:mysql://127.0.0.1/warehouse?\"+ \"user=root&password=&characterEncoding=gb2312\"; con=DriverManager.getConnection(uri); String condition = \"UPDATE product SET name = ?,price = ?,madeTime = ? WHERE number=?\"; sql=con.prepareStatement(condition); sql.setString(1,name); //设置第1个统配符“？”代表的具体值 sql.setFloat(2,price); //设置第2个统配符“？”代表的具体值 sql.setDate(3,date); //设置第3个统配符“？”代表的具体值 sql.setString(4,number); //设置第4个统配符“？”代表的具体值 sql.executeUpdate(); sql=con.prepareStatement(\"select * from product\"); rs=sql.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); //得到结果集的列数 String []columnName = new String[columnCount]; for(int i=0;i\"); out.println(\"\"+backNews+\"\") ; out.println(\"返回\"); out.println(\"输入记录\"); out.println(\"\"); } catch(IOException exp){} } } 事务 ​ 事务由一组SQL语句组成，所谓“事务处理”是指：应用程序保证事务中的SQL语句要么全部都执行，要么一个都不执行。 事务处理步骤如下： 1．连接对象使用setAutoCommit(boolean autoCommit)方法 将参数autoCommit取值为false来关闭自动提交模式： con.setAutoCommit(false); 2．commit()方法 con调用commit()方法就是让事务中的SQL语句全部生效。 3．rollback()方法 只要事务中任何一个SQL语句没有生效,就抛出SQLException异常。在处理SQLException异常时,必须让con调用rollback()方法,其作用是撤消事务中成功执行过的SQL语句对数据库数据所做的更新、插入或删除操作. ​ 为了例子7的需要，我们在bank数据库中创建了表user表,表的字段及属性如下： name(文本) userMoney(双精度型) ​ 例子7使用了事务处理,将user表中name字段是geng的userMoney的值减少50,并将减少的50增加到name字段是zhang的userMony属性值上。运行效果如图7.23. \"); out.print(\"转账前zhang的userMoney的值是\"+zhangMoney+\"\"); gengMoney=gengMoney-n; if(gengMoney>=0) { zhangMoney=zhangMoney+n; sql.executeUpdate (\"UPDATE user SET userMoney =\"+gengMoney+\" WHERE name='geng'\"); sql.executeUpdate (\"UPDATE user SET userMoney=\"+zhangMoney+\" WHERE name='zhang'\"); con.commit(); //开始事务处理 } rs=sql.executeQuery(\"SELECT * FROM user WHERE name='zhang'||name='geng'\"); out.println(\"转账后的情况如下:\"); while(rs.next()) { out.print(rs.getString(1)+\" \"); out.print(rs.getString(2)); out.print(\"\"); } con.close(); } catch(SQLException e){ try{ con.rollback(); //撤消事务所做的操作 } catch(SQLException exp){} out.println(e); } %> 分页显示记录 可以使用二维数组table存放表的记录，即用二维数组table中的行（一维数组table[i]）存放一条记录。 假设table存放了m行记录，准备每页显示n行，那么，总页数的计算公式： 如果m除以n的余数大于0,总页数等于m除以n的商加1； 如果m除以n的余数等于0，总页数等于m除以n的商。 总页数=(m%n)==0?(m/n):(m/n+1); 如果准备显示第p页的内容，应当从tablel第(p-1)*n行开始，连续输出n行（最后一页可能不足n行）。 ​ 下面的例子8使用MVC模式分页显示warehouse数据库product表中的记录。 ​ 根据例子8中使用的servlet的名字及相关类，Web服务目录ch7的WEB-INF下的web.xml文件需包含如下内容 queryAllServlet myservlet.control.Example7_8_Servlet queryAllServlet /queryAllServlet ​ 模型（Javabean） ​ Javabean模型的id是pageBean（Example7_8_Bean创建），生命周期是session，用于存储数据库中的记录。 package mybean.data; public class Example7_8_Bean{ String []columnName ; //存放列名 String [][] tableRecord=null; //存放查询到的记录 int pageSize=1; //每页显示的记录数 int totalPages=1; //分页后的总页数 int currentPage =1 ; //当前显示页 public void setTableRecord(String [][] s){ tableRecord=s; } public String [][] getTableRecord(){ return tableRecord; } public void setColumnName(String [] s) { columnName = s; } public String [] getColumnName() { return columnName; } public void setPageSize(int size){ pageSize=size; } public int getPageSize(){ return pageSize; } public int getTotalPages(){ return totalPages; } public void setTotalPages(int n){ totalPages=n; } public void setCurrentPage(int n){ currentPage =n; } public int getCurrentPage(){ return currentPage ; } } 视图（JSP页面） 视图部分由2个JSP页面构成，其中example7_8.jsp页面负责提供输入数据的视图，即用户可以在该页面输入数据库的名、表名、密码等信息，然后提交给名字是queryAllServlet的servlet。queryAllServlet负责查询数据库，并将结果存储到id为pageBean的Javabean数据模型中，然后请求视图中的example7_8_pageShow.jsp页面负责分页显示pageBean的数据。example7_8.jsp和example7_8_pageShow.jsp的效果如图7.24(a)和图7.24(b)所示。 数据库: 表名： 用户名(默认root)： 用户密码(默认空)： 当前显示的内容是： \"); for(int i=0;i\"+columnName[i]+\"\"); } out.print(\"\"); } int totalRecord = table.length; out.println(\"全部记录数\"+totalRecord); //全部记录数 int pageSize=pageBean.getPageSize(); //每页显示的记录数 int totalPages = pageBean.getTotalPages(); if(totalRecord%pageSize==0) totalPages = totalRecord/pageSize;//总页数 else totalPages = totalRecord/pageSize+1; pageBean.setPageSize(pageSize); pageBean.setTotalPages(totalPages); if(totalPages>=1) { if(pageBean.getCurrentPage()pageBean.getTotalPages()) pageBean.setCurrentPage(1); int index=(pageBean.getCurrentPage()-1)*pageSize; int start=index; //table的currentPage页起始位置 for(int i=index;i\"); for(int j=0;j\"+table[i][j]+\"\"); } out.print(\"\"); } } %> 每页最多显示条信息 当前显示第 页,共有 页。 \"> \"> 每页显示 条记录 输入页码： 控制器（servlet） Example7_8_Servlet负责创建名字是queryAllServlet的servlet（见例子8前面web.xml文件的有关内容）。queryAllServlet查询数据库表中的全部记录，将结果存放到id是pageBean的Javabean数据模型中，然后用转发的方法请求example7_8_pageShow.jsp显示pageBean中的数据。 package myservlet.control; import mybean.data.Example7_8_Bean; import java.sql.*; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class Example7_8_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); try { Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ request.setCharacterEncoding(\"gb2312\"); String dataBase= request.getParameter(\"dataBase\"); String tableName= request.getParameter(\"tableName\"); String user= request.getParameter(\"user\"); String password= request.getParameter(\"password\"); boolean boo =( dataBase==null||dataBase.length()==0); boo = boo||( tableName==null||tableName.length()==0); boo = boo||( user==null||user.length()==0); if(boo) { fail(request,response,\"查询失败\"); } HttpSession session=request.getSession(true); Connection con=null; Example7_8_Bean pageBean=null; try{ pageBean=(Example7_8_Bean)session.getAttribute(\"pageBean\"); if(pageBean==null){ pageBean=new Example7_8_Bean(); //创建Javabean对象 session.setAttribute(\"pageBean\",pageBean); } } catch(Exception exp){ pageBean=new Example7_8_Bean(); session.setAttribute(\"pageBean\",pageBean); } String uri=\"jdbc:mysql://127.0.0.1/\"+dataBase; try{ con=DriverManager.getConnection(uri,user,password); Statement sql=con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY); ResultSet rs=sql.executeQuery(\"SELECT * FROM \"+tableName); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); //得到结果集的列数 String []columnName = new String[columnCount]; for(int i=0;i\"); out.println(\"\"+backNews+\"\") ; out.println(\"返回\"); out.println(\"输入正确信息\"); out.println(\"\"); } catch(IOException exp){} } } 常见数据库连接 连接Microsoft SQL Server数据库 try { Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); } catch(Exception e){ } try{ String uri= \"jdbc:sqlserver://192.168.100.1:1433;DatabaseName=warehouse\"; String user=\"sa\"; String password=\"dog123456\"; con=DriverManager.getConnection(uri,user,password); } catch(SQLException e){ System.out.println(e); } 连接Oracle数据库 Class.forName(\"oracle.jdbc.driver.OracleDriver\").newInstance(); Connection con= DriverManager.getConnection( \"jdbc:oracle:thin:@主机:端口号:数据库名\",\"用户名\",\"密码\"); 例如： String user=\"scott\"; String password=\"tiger\"; con = DriverManager.getConnection (\"jdbc:oracle:thin:@192.168.96.1:1521:oracle9i\",user,password); 连接Microsoft Access数据库 Class.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\"); Connection con = DriverManager.getConnection(\"jdbc:odbc:数据源名字“, \"loginName\",\" password \") 连接Access数据库shop、查询其中的goods表。 \"); out.print(\"\"); out.print(\"\"+\"产品号\"); out.print(\"\"+\"名称\"); out.print(\"\"+\"生产日期\"); out.print(\"\"+\"价格\"); out.print(\"\"); while(rs.next()){ out.print(\"\"); out.print(\"\"+rs.getString(1)+\"\"); out.print(\"\"+rs.getString(2)+\"\"); out.print(\"\"+rs.getDate(\"madeTime\")+\"\"); out.print(\"\"+rs.getFloat(\"price\")+\"\"); out.print(\"\") ; } out.print(\"\"); con.close(); } catch(SQLException e){ out.print(e); } %> 标准化考试 我们很熟悉标准化考试，就是只需在给出的选择中选出正确的答案。在本节的标准化考试中，用户只能顺序的回答每个随机抽取到的题目，即回答一个题目，然后读取下一个题目后，用户就不能再回到上一个题目（类似新的驾驶员交通理论考试规则）。 设计要求 1.考生可以在输入考号的页面输入考号，单击确认提交键开始考试。 2.考生单击确认提交键后，可以在答题页面看到随机抽取到的第1题。 3.考生回答一个题目后，可以继续随机抽取下一题目。 4.考生在答题页面单击交卷提交键，完成考试，系统将给出考生的分数。 数据库设计 创建一个名字为school的数据库，在数据库中使用test表存放试题。test表的各个字段及意义如下： number(int) ：存放题号, content(char) ：存放试题内容 , a(char) ：存放试题提供的a选择 , b(char) ：存放试题提供的b选择, c(char) ：存放试题提供的c选择, d(char) ：存放试题提供的d选择, pic(char) ：存放试题示意图的图像文件的名字 , answer(char) ：存放试题的答案 使用student表存放考生的学号和分数。student表的各个字段及意义如下： id(char) ：存放考号, score(float) ：存放分数。 ​ 例子10给出设计的有关代码，使用MVC模式设计标准化考试。 ​ 根据例子10中使用的servlet的名字及相关类，Web服务目录ch7的WEB-INF下的web.xml文件需包含如下内容： readTestServlet myservlet.control.Example7_10_Servlet readTestServlet /readTestServlet endTestServlet myservlet.control.Example7_10_End_Servlet endTestServlet /endTestServlet ​ 模型（Javabean） ​ Javabean模型Example7_10_Bean.java负责存储试题以及考生的学号和考试得分的有关信息，在本例子中Example7_10_Bean创建的Javabean模型的id是testBean，scope取值是session。 package mybean.data; public class Example7_10_Bean{ String id ; //存放考号 float score; //存放分数 String questions; //存放题目 int number; //存放题号 int textAmount=3 ; //题目数量 String choiceA,choiceB,choiceC,choiceD;//存放选择 String image; //题目的示意图的图像文件名 String answer; //存放用户给出的答案 String correctAnswer; //存放正确答案 String mess; //存放提示信息 public String getCorrectAnswer() { return correctAnswer; } public void setCorrectAnswer(String s){ correctAnswer =s; } public void setId(String s){ id=s; } public String getId(){ return id; } public void setScore(float s) { score = s; } public float getScore() { return score; } public void setQuestions(String s){ questions=s; } public String getQuestions(){ return questions; } public void setNumber(int s){ number=s; } public int getNumber(){ return number; } public void setChoiceA(String s){ choiceA=s; } public String getChoiceA(){ return choiceA; } public void setChoiceB(String s){ choiceB=s; } public String getChoiceB(){ return choiceB; } public void setChoiceC(String s){ choiceC=s; } public String getChoiceC(){ return choiceC; } public void setChoiceD(String s){ choiceD=s; } public String getChoiceD(){ return choiceD; } public void setImage(String s){ image=s; } public String getImage(){ return image; } public void setAnswer(String s){ answer=s; } public String getAnswer(){ return answer; } public void setMess(String s){ mess=s; } public String getMess(){ return mess; } public void setTestAmount(int s){ textAmount=s; } public int getTestAmount(){ return textAmount; } } 视图（JSP页面） 视图部分由2个JSP页面构成，其中example7_10.jsp页面负责提供输入考号，单击开始考试按钮。 example7_10_examination.jsp显示数据模型testBean中的数据。用户在example7_10_examination.jsp页面阅读试题，并提给出自己的答案，该答案被存放到到testBean中。 用户在example7_10_examination.jsp页面可以单击下一题目提交给名字是readTestServlet的servlet， 在example7_10_examination.jsp页面还可以单击交卷提交键结束考试，即请求名字是endServlet的servlet。 example7_10.jsp和example7_10_examination.jsp的效果如图7.31(a)(b)所示。 考题数量是 输入考号 =1) { %> width=100 height=60> =1){ testBean.setAnswer(studentAnswer.trim()); } %> 目前分数： , 消息： 选择:A B C D 你目前给出的选择是 \" name =\"id\"> 控制器（servlet） 有2个控制器Example7_10_Sevlet和Example7_10_End_Servlet。 Example7_10_Sevlet负责创建名字是readTestServlet的servlet。readTestServlet负责从数据库的test表中读入试题存放到id是testBean的Javabean数据模型中，然后请求example7_10_examation.jsp显示testBean中的数据。另外，readTestServlet还接收用户提交的答案，并与test表中的答案进行比较，给出用户的得分。 Example7_10_End_Servlet负责创建名字是endSerlet的servlet，用户单击交卷提交键，该servlet负责将用户的名和分数添加到数据库。 package myservlet.control; import mybean.data.Example7_10_Bean; //引入Javabean模型 import java.io.*; import java.sql.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.*; public class Example7_10_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Example7_10_Bean testBean=null; HttpSession session=request.getSession(true); try{ testBean=(Example7_10_Bean)session.getAttribute(\"testBean\"); if(testBean==null){ testBean=new Example7_10_Bean(); //创建Javabean对象 session.setAttribute(\"testBean\",testBean); } } catch(Exception exp){ testBean=new Example7_10_Bean(); //创建Javabean对象 session.setAttribute(\"testBean\",testBean); } try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} request.setCharacterEncoding(\"gb2312\"); String id=request.getParameter(\"id\"); if(id==null||id.length()==0) { notify(request,response,\"必须给出学号\"); return; } testBean.setId(id); int testAmount = testBean.getTestAmount(); //考题数量 Connection con; Statement sql; ResultSet rs; try{ String uri=\"jdbc:mysql://127.0.0.1/school?\"+ \"user=root&password=&characterEncoding=gb2312\"; con=DriverManager.getConnection(uri); sql=con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY); rs=sql.executeQuery(\"SELECT * FROM test\"); rs.last(); int recordAmount=rs.getRow(); //得到记录数 testAmount = Math.min(recordAmount,testAmount); LinkedList list=(LinkedList)session.getAttribute(\"list\"); if(list==null||list.size()==0){ list = new LinkedList(); for(int i=1;i=1) { m= (int)(Math.random()*list.size()); index=list.get(m); list.remove(m); session.setAttribute(\"list\",list); int tihao=testBean.getNumber(); if(tihao=1) { if(studentAnswer.equalsIgnoreCase(testBean.getCorrectAnswer())){ float score= testBean.getScore(); score++; testBean.setScore(score); } } //随机抽取下一题目： tihao++; testBean.setNumber(tihao); //题号 rs.absolute(index); //随机抽取题目 testBean.setQuestions(rs.getString(1));//题目内容 testBean.setChoiceA(rs.getString(2)); //题目的选择a testBean.setChoiceB(rs.getString(3)); //题目的选择b testBean.setChoiceC(rs.getString(4)); //题目的选择c testBean.setChoiceD(rs.getString(5)); //题目的选择d testBean.setImage(rs.getString(6)); //题目的示意图名称 testBean.setCorrectAnswer(rs.getString(7).trim());//题目的答案 testBean.setMess(\"现在是第\"+tihao+\"题\"); con.close(); } else { testBean.setMess(\"答题结束，单击交卷查看分数\"); String studentAnswer=testBean.getAnswer(); //判断最后一题 if(studentAnswer!=null&&studentAnswer.length()>=1) { if(studentAnswer.equalsIgnoreCase(testBean.getCorrectAnswer())){ float score= testBean.getScore(); score++; testBean.setScore(score); } } testBean.setAnswer(null); testBean.setNumber(0); testBean.setQuestions(null); testBean.setChoiceA(null); testBean.setChoiceB(null); testBean.setChoiceC(null); testBean.setChoiceD(null); testBean.setImage(null); } } else { testBean.setMess(\"没有抽到题目\"); } response.sendRedirect(\"example7_10_examination.jsp\"); } catch(SQLException e){ notify(request,response,e.toString()); } } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ doPost(request,response); } public void notify(HttpServletRequest request,HttpServletResponse response, String backNews) { response.setContentType(\"text/html;charset=GB2312\"); try { PrintWriter out=response.getWriter(); out.println(\"\"); out.println(\"\"+backNews+\"\") ; out.println(\"返回\"); out.println(\"返回\"); out.println(\"\"); } catch(IOException exp){} } } package myservlet.control; import mybean.data.Example7_10_Bean; //引入Javabean模型 import java.io.*; import java.sql.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.*; public class Example7_10_End_Servlet extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Example7_10_Bean testBean=null; HttpSession session=request.getSession(true); try{ testBean=(Example7_10_Bean)session.getAttribute(\"testBean\"); } catch(Exception exp){ response.sendRedirect(\"example7_10.jsp\"); } try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} request.setCharacterEncoding(\"gb2312\"); String id=testBean.getId(); Connection con; Statement sql; String condition = \"INSERT INTO student VALUES\"+ \"(\"+\"'\"+id+\"',\"+testBean.getScore()+\")\"; try{ String uri=\"jdbc:mysql://127.0.0.1/school?\"+ \"user=root&password=&characterEncoding=gb2312\"; con=DriverManager.getConnection(uri); sql=con.createStatement(); sql.executeUpdate(condition); float score = testBean.getScore(); notify(request,response,id+\"最后得分:\"+score); session.invalidate(); //销毁用户的session对象 } catch(SQLException exp){} } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ doPost(request,response); } public void notify(HttpServletRequest request,HttpServletResponse response, String backNews) { response.setContentType(\"text/html;charset=GB2312\"); try { PrintWriter out=response.getWriter(); out.println(\"\"); out.println(\"\"+backNews+\"\") ; out.println(\"\"); } catch(IOException exp){} } } JSP使用JDBC提供的API和数据库进行交互信息。JDBC技术在数据库开发中占有很重要的地位，JDBC操作不同的数据库仅仅是连接方式上的差异而已，使用JDBC的应用程序一旦和数据库建立连接，就可以使用JDBC提供的API操作数据库。 当查询ResultSet对象中的数据时，不可以关闭和数据库的连接。 使用PreparedStatement对象可以提高操作数据库的效率 "},"page/1042.html":{"url":"page/1042.html","title":"XML","keywords":"","body":"XML "},"page/1043.html":{"url":"page/1043.html","title":"MVC","keywords":"","body":"MVC ​ MVC模式的核心思想是有效地组合“视图”、“模型”和“控制器”。 本章将介绍MVC模式，掌握该模式对于设计合理的Web应用以及学习使用某些流行的Web框架，如Hibernate，Spring，Struts等，都有着十分重要的意义。 MVC模式介绍 ​ MVC是一种通过三个不同部分构造一个软件或组件的理想办法： 模型（Model）——用于存储数据的对象。 视图（View）——为模型提供数据显示的对象。 控制器（Controller）——负责具体的业务逻辑操作，即控制器根据视图提出的要求对数据做出处理，并将有关结果存储到模型中，同时负责让模型和视图进行必要的交互，当模型中的数据变化时，让视图更新显示。 JSP中的MVC模式 ​ 在JSP技术中，“视图”、“模型”和“控制器”的具体实现如下： 模型（Model）： 一个或多个JavaBean对象，用于存储数据，JavaBean主要提供简单的setXXX()方法和getXXX()方法，在这些方法中不涉及对数据的具体处理细节。 视图（View）： ​ 一个或多个JSP页面，为模型提供数据显示，JSP页面主要使用 HTML标记和JavaBean标记来显示数据。 控制器（Controller）： ​ 一个或多个Servlet对象，根据视图提交的要求进行数据处理操作，并将有关的结果存储到JavaBean中，然后Servlet使用重定向方式请求视图中的某个JSP页面更新显示. 模型的生命周期与视图更新 ​ 在JSP+Javabean模式中，由JSP页面通过使用useBean标记： 创建Javabean。 ​ JSP中的MVC模式中，也可以由控制器servet创建Javabean，并将有关数据存储到所创建的Javabean中，然后servlet请求某个JSP页面使用Javabean的getProperty动作标记： 显示Javabean的中的数据。 ​ 在JSP中的MVC模式中，非常重要的手段是由servlet负责用构造方法创建Javabean，因此允许创建Javabean的类可以有带参数的构造方法。 ​ 在JSP中的MVC模式中，servet创建的Javabean也涉及到生命周期(有效期限)，生命周期分为request、session和application。以下假设创建Javabean的类的名字是BeanClass，该类的包名为user.yourbean 。 request周期的Javabean Javabean的创建 servlet负责创建bean。那么创建生命周期为request的bean的步骤如下： （1）用BeanClass类的某个构造方法创建bean对象，例如： BeanClass bean=new BeanClass(); （2）将所创建的bean对象存放到HttpSerletRequest对象request中，并指定查找该bean的关键字，该步骤决定了bean的生命周期为request。例如： request.setAttribute(\"keyWord\",bean); 执行上述操作，就会把bean存放到Tomcat引擎管理的内置对象pageContext中，该bean被指定的id是\"keyWord\"，生命周期是 PageContext.REQUEST_SCOPE（request）。 视图更新 ​ servlet请求一个JSP页面，比如show.jsp的代码如下： RequestDispatcher dispatcher= request.getRequestDispatcher(\"show.jsp\"); dispatcher.forward(request,response); ​ servlet所请求的JSP页面可以使用如下标记获得servlet所创建的bean的引用（type属性使得该JSP页面不负责创建bean）： 该标记中的id是servlet所创建的bean索引关键字。然后JSP页面使用标记显示bean中的数据。如果上述代码执行成功，用户就看到了show.jsp页面的执行效果。 ​ 特别注意: 如果servlet所请求的JSP页面,使用如下标记获得servlet所创建的bean的引用(注意没有用type属性而是用class属性)： 该标记中的id是servlet所创建的bean索引关键字。那么即使servlet所请求的JSP页面事先已经有了id是\"keyWord\"，scope是\"request\"的bean，那么这个bean也会被servlet所创建的bean替换。 ​ 原因是servlet所请求的JSP页面会被刷新，就会根据当前页面使用的 标记到Tomcat引擎管理的内置对象PageContext中寻找id是\"keyWord\"，生命周期是request，而该bean已经被servlet更新了。 session周期的Javabean Javabean的创建 servet创建生命周期为session的bean的步骤如下： （1）用BeanClass类的某个构造方法创建bean对象，例如： BeanClass bean=new BeanClass(); （2）将所创建的bean对象存放到HttpSerletSession对象：session中，并指定查找该bean的关键字，该步骤决定了bean的生命周期为session。例如： HttpSession session=request.getSession(true); session.setAttribute(\"keyWord\",bean); 内置对象执行上述操作，就会把bean存放到Tomcat引擎管理的内置对象pageContext中，该bean被指定的id是\"keyWord\"，生命周期是PageContext.SESSION_SCOPE（session）。 视图更新 ​ servelt创建bean,bean的生命周期为session，只要用户的session没有消失，该bean就一直存在，一个用户在访问Web服务目录的各个JSP中都可以使用 标记获得servlet所创建的bean的引用，然后使用标记显示该bean中的数据，该标记中的id是servlet所创建的bean索引关键字。 ​ 对于生命周期为session的bean，如果servlet希望某个JSP显示其中的数据，可以使用RequestDispatcher对象向该JSP页面发出请求，也可以使用HttpServletResponse类中的重定向方法（sendRedirect）。 ​ show.jsp页面使用如下标记获得servlet所创建的bean的引用(注意没有用type属性而是用class属性)：该标记中的id是servlet所创建的bean索引关键字。那么即使servlet所请求的JSP页面或其他页面事先已经有了id是\"keyWord\"，scope是\" session \"的bean，那么这个bean也会被servlet所创建的bean替换。 ​ 原因是，servlet所请求的JSP页面或其他页面被刷新时，就会根据当前页面使用的标记到Tomcat引擎管理的内置对象PageContext中寻找id是\"keyWord\"，生命周期是session,而该bean已经被servlet更新了。 application周期的Javabean Javabean的创建 ​ servet创建生命周期为application的bean的步骤如下： （1）用BeanClass类的某个构造方法创建bean对象，例如： ​ BeanClass bean=new BeanClass(); （2）servlet使用getServletContext()方法返回服务器的ServletContext内置对象的引用，将所创建的bean对象存放到服务器这个ServletContext内置对象中，并指定查找该bean的关键字，该步骤决定了bean的生命周期为application，例如： ​ getServletContext().setAttribute(\"keyWord\",bean); 上述操作，就会把bean存放到Tomcat引擎管理的内置对象pageContext中，该bean被指定的id是\"keyWord\"，有效期限是（生命周期）PageContext.APPLICATION_SCOPE（application）。 视图更新 ​ 当servlet创建创建生命周期为application的bean后，只要Web应用程序不结束，该bean就一直存在。一个用户在访问Web服务目录的各个JSP中都可以使用 标记获得servlet所创建的bean的引用，然后使用 标记显示该Javabean中的数据，该标记中的id是servlet所创建的bean索引关键字。 ​ 对于生命周期为application的bean，如果servlet希望某个JSP显示其中的数据，可以使用RequestDispatcher对象向该JSP页面发出请求，也可以使用HttpServletResponse类中的重定向方法（sendRedirect）。 ​ 注意:所有用户在同一个Web服务目录中的application生命周期的bean是相同的，即占有相同的内存空间。另外,如果servlet所请求的JSP页面，比如show.jsp页面，使用如下标记获得servlet所创建的bean的引用(注意没有用type属性而是用class属性)：该标记中的id是servlet所创建的bean索引关键字。那么即使servlet所请求的JSP页面或其他事先已经有了id是\"keyWord\"，scope是\"application\"的bean，那么这个bean也会被servlet所创建的bean替换。 原因是，servlet所请求的JSP页面或其他页面被刷新时，就会根据当前页面使用的：标记到Tomcat引擎管理的内置对象PageContext中寻找id是\"keyWord\"，生命周期是application，而该bean已经被servlet更新了。 MVC模式的简单实例 本节结合一个简单的实例体现MVC三个部分的设计与实现。 计算三角形和 梯形的面积 Javabean和Servlet与配置文件 按着本章的约定Javabean类的包名均为mybean.data；Servlet类的包名均为myservlet.control。 1．保存Javabean类和Servlet类的源文件 D:\\ mybean\\data 和 D:\\myservlet\\control 2．编译Javabean类 D:> javac mybean\\data\\Javabean的源文件 3．编译Servlet类 D:> javac myservlet\\control\\servlet的源文件 4．将类的字节码文件保存到服务器 ch9\\WEB-INF\\classes\\mybean\\data 和ch9\\WEB-INF\\classes\\myservlet\\control 5．web.xml文件 编写web.xml文件，并保存到Web服务目录的WEB-INF子目录中，即ch9\\WEB-INF中 。 计算三角形和梯形的面积 设计一个Web应用，该Web应用提供两个JSP页面，一个页面使得用户可以输入三角形三边的值和梯形的上底、下底和高的值；另一个页面可以显示三角形和梯形的面积。Web应用提供一个名字为computerArea的servlet对象，computerArea负责计算三角形和梯形的面积（computerArea由HandleArea类负责创建，访问它的url-pattern为lookArea，见前面的web.xml中的配置），然后将有关数据存储到Javabean中。Web应用提供的Javabean负责存储数据结果，该Javabean提供简单的获取数据和修改数据的方法。 1．模型（Javabean） Area.java 本模型Area.java中的getXxx和setXxx方法不涉及对数据的具体处理细节，以便增强模型的通用性。 package mybean.data; public class Area{ double a,b,c,area; String mess; public void setMess(String mess){ this.mess=mess; } public String getMess(){ return mess; } public void setA(double a){ this.a=a; } public void setB(double b){ this.b=b; } public void setC(double c){ this.c=c; } public void setArea(double s){ area=s; } public double getArea(){ return area; } } 2．控制器（servlet） HandleArea .java 控制器是名字为computerArea的servlet对象（见web.xml中的配置），由下面的Servlet类负责创建。控制器使用doPost方法计算三角形的面积；使用doGet方法计算梯形的面积 。 package myservlet.control; import mybean.data.Area; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class HandleArea extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Area dataBean=new Area(); //创建Javabean对象 request.setAttribute(\"data\",dataBean);//将dataBean存储到request对象中 try{ double a=Double.parseDouble(request.getParameter(\"a\")); double b=Double.parseDouble(request.getParameter(\"b\")); double c=Double.parseDouble(request.getParameter(\"c\")); dataBean.setA(a); //将数据存储在dataBean中 dataBean.setB(b); dataBean.setC(c); double s=-1; double p=(a+b+c)/2.0; if(a+b>c&&a+c>b&&b+c>a) s=Math.sqrt(p*(p-a)*(p-b)*(p-c)); dataBean.setArea(s); //将数据存储在dataBean中 dataBean.setMess(\"三角形面积\"); } catch(Exception e){ dataBean.setArea(-1); dataBean.setMess(\"\"+e); } RequestDispatcher dispatcher=request.getRequestDispatcher(\"showResult.jsp\"); //请求showResult.jsp显示dataBean中的数据: dispatcher.forward(request,response); } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Area dataBean=new Area(); //创建Javabean对象 request.setAttribute(\"data\",dataBean);//将dataBean存储到request对象中 try{ double a=Double.parseDouble(request.getParameter(\"a\")); double b=Double.parseDouble(request.getParameter(\"b\")); double c=Double.parseDouble(request.getParameter(\"c\")); dataBean.setA(a); //将数据存储在dataBean中 dataBean.setB(b); dataBean.setC(c); double s=-1; s=(a+b)*c/2.0; dataBean.setArea(s); //将数据存储在dataBean中 dataBean.setMess(\"梯形面积\"); } catch(Exception e){ dataBean.setArea(-1); dataBean.setMess(\"\"+e); } RequestDispatcher dispatcher=request.getRequestDispatcher(\"showResult.jsp\"); //请求showResult.jsp显示dataBean中的数据 : dispatcher.forward(request,response); } } 3．视图（JSP页面） 在inputData.jsp页面可以输入三角形三边的值或梯形的上、下底和高的值，并将所输入的三角形三边的值和梯形的上、下底和高的值分别用post方法和get方法提交给名字为computerArea的servlet对象。computerArea使用doPost方法计算三角形的面积；使用doGet方法计算梯形的面积，并将结果存储到数据模型bean中，然后请求showResult.jsp页面显示模型中的数据。 inputData.jsp（效果如图9-3） showResult.jsp（效果如图9-4） 三角形： 输入边A: 输入边B: 输入边C: 梯形： 输入上底: 输入下底: 输入高: : MVC模式与注册登录 ​ 大部分Web应用都会涉及到注册与登录模块。本节使用MVC模式讲述怎样设计注册、登录模块。为ch9\\WEB-INF中的web.xml文件添加如下子标记 Javabean与Servlet管理 本节的Javabean类的包名均为mybean.data；Servlet类的包名均为myservlet.control。 1．保存Javabean类和Servlet类的源文件 D:\\ mybean\\data 和 D:\\myservlet\\control 2．编译Javabean类 D:> javac mybean\\data\\Javabean的源文件 3．编译Servlet类 D:> javac myservlet\\control\\servlet的源文件 4．将类的字节码文件保存到服务器 ch9\\WEB-INF\\classes\\mybean\\data 和 ch9\\WEB-INF\\classes\\myservlet\\control 配置文件管理 本节的Servlet类的包名均为myservlet.control，需要配置Web服务目录的web.xml文件，即将下面的web.xml文件保存到Tomcat安装目录的Web服务目录ch9中。根据本书使用的Tomcat安装目录及Web服务目录，需要将web.xml文件保存到D:\\apache-tomcat-8.0.3\\webapps\\ch9\\WEB-INF目录中。 web.xml register myservlet.control.HandleRegister register /helpRegister login myservlet.control.HandleLogin login /helpLogin 数据库设计与连接 使用MySQL建立一个数据库student，该库共有一个user表 。 ​ user表的用途：存储用户的注册信息。即会员的注册信息存入user表中，user表的主键是logname，各个字段值的说明如下： logname ：存储注册的用户名（属性是字符型，主键）。 password ：存储密码（属性是字符型）。 email ：存储email（属性是字符型）。 ​ 避免操作数据库出现中文乱码，需要使用 ​ Connection getConnection(java.lang.String) 方法建立连接，连接中的代码是（用户是root，其密码是空）： String uri = \"jdbc:mysql://127.0.0.1/student?\"+ \"user=root&password=&characterEncoding=gb2312\"; Connection con = DriverManager.getConnection(uri); 注册 ​ 当新会员注册时，该模块要求用户必须输入会员名、密码信息，否则不允许注册。用户的注册信息被存入数据库的user表中。 ​ 该模块视图部分由一个JSP页面构成，这个JSP页面register.jsp负责提交用户的注册信息到servlet控制器register（见配置文件web.xml），并负责显示注册是否成功的信息。该模块的Javabean模型userBean存储用户的注册信息。servlet控制器register负责将视图提交的信息写入数据库的user表中，并将有关反馈信息存储到Javabean模型userBean中，然后将用户转发到register.jsp，register.jsp将显示Javabean模型userBean中的数据（更新视图）,效果如图9-6所示。 1．视图（JSP页面） register .jsp 2．模型（Javabean） Register .java 3．控制器（servlet） HandleRegister .java 注册页面 用户名由字母、数字、下划线构成，*注释的项必须填写。 *用户名称: *用户密码: *重复密码: email: 注册反馈： 会员名称: email地址: package mybean.data; public class Register{ String logname=\"\" , email=\"\", backNews=\"请填注册信息\"; public void setLogname(String logname){ this.logname=logname; } public String getLogname(){ return logname; } public void setEmail(String email){ this.email=email; } public String getEmail(){ return email; } public void setBackNews(String backNews){ this.backNews=backNews; } public String getBackNews(){ return backNews; } } package myservlet.control; import mybean.data.*; import java.sql.*; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class HandleRegister extends HttpServlet { public void init(ServletConfig config) throws ServletException { super.init(config); try { Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} } public String handleString(String s) { try{ byte bb[]=s.getBytes(\"iso-8859-1\"); s=new String(bb); } catch(Exception ee){} return s; } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException { String uri=\"jdbc:mysql://127.0.0.1/student?\"+ \"user=root&password=&characterEncoding=gb2312\"; Connection con; PreparedStatement sql; Register userBean=new Register(); //创建的Javabean模型 request.setAttribute(\"userBean\",userBean);//将会更新id是\"userBean\"的bean String logname=request.getParameter(\"logname\").trim(); String password=request.getParameter(\"password\").trim(); String again_password=request.getParameter(\"again_password\").trim(); String email=request.getParameter(\"email\").trim(); if(logname==null) logname=\"\"; if(password==null) password=\"\"; if(!password.equals(again_password)) { userBean.setBackNews(\"两次密码不同，注册失败，\"); RequestDispatcher dispatcher= request.getRequestDispatcher(\"register.jsp\"); dispatcher.forward(request, response);//转发 return; } boolean isLD=true; for(int i=0;i='a')||(c='A')||(c='0'))) isLD=false; } boolean boo=logname.length()>0&&password.length()>0&&isLD; String backNews=\"\"; try{ con=DriverManager.getConnection(uri); String insertCondition=\"INSERT INTO user VALUES (?,?,?)\"; sql=con.prepareStatement(insertCondition); if(boo) { sql.setString(1,handleString(logname)); sql.setString(2,handleString(password)); sql.setString(3,handleString(email)); int m=sql.executeUpdate(); if(m!=0){ backNews=\"注册成功\"; userBean.setBackNews(backNews); userBean.setLogname(logname); userBean.setEmail(handleString(email)); } } else { backNews=\"信息填写不完整或名字中有非法字符\"; userBean.setBackNews(backNews); } con.close(); } catch(SQLException exp){ backNews=\"该会员名已被使用，请您更换名字\"+exp; userBean.setBackNews(backNews); } RequestDispatcher dispatcher= request.getRequestDispatcher(\"register.jsp\"); dispatcher.forward(request, response);//转发 } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException { doPost(request,response); } } 登录与验证 ​ 用户可在该模块输入自己的会员名和密码,系统将对会员名和密码进行验证,如果输入用户名或密码有错误,将提示用户输入的用户名或密码不正确。 ​ 该模块视图部分由2个JSP页面longin.jsp和lookPic.jsp构成，longin.jsp页面负责提交用户的登录信息到控制器，并显示登录是否成功的信息，登录成功后lookPic.jsp页面负责显示一幅图像，如果没有登录，用户访问lookPic.jsp页面会被转发到longin.jsp登录页面。该模块的Javabean模型loginBean存储用户登录的信息。该模块的servlet控制器login负责验证会员名和密码是否正确，并负责更新视图。 1．视图（JSP页面） login.jsp 2．模型（Javabean） Login.java 3．控制器（servlet） HandleLogin.java 4．验证 lookPic.jsp 登录 登录名称: 输入密码: \"> 登录后看图片 登录反馈信息: 登录名称: package mybean.data; public class Login { String logname=\"\", backNews=\"未登录\"; public void setLogname(String logname){ this.logname=logname; } public String getLogname(){ return logname; } public void setBackNews(String s) { backNews=s; } public String getBackNews() { return backNews; } } package myservlet.control; import mybean.data.*; import java.sql.*; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class HandleLogin extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} } public String handleString(String s){ try{ byte bb[]=s.getBytes(\"iso-8859-1\"); s=new String(bb); } catch(Exception ee){} return s; } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Connection con; Statement sql; String logname=request.getParameter(\"logname\").trim(), password=request.getParameter(\"password\").trim(); logname=handleString(logname); password=handleString(password); String uri=\"jdbc:mysql://127.0.0.1/student?\"+ \"user=root&password=&characterEncoding=gb2312\"; boolean boo=(logname.length()>0)&&(password.length()>0); try{ con=DriverManager.getConnection(uri); String condition=\"select * from user where logname = '\"+logname+ \"' and password ='\"+password+\"'\"; sql=con.createStatement(); if(boo){ ResultSet rs=sql.executeQuery(condition); boolean m=rs.next(); if(m==true){ //调用登录成功的方法: success(request,response,logname,password); RequestDispatcher dispatcher= request.getRequestDispatcher(\"login.jsp\");//转发 dispatcher.forward(request,response); } else{ String backNews=\"您输入的用户名不存在，或密码不般配\"; //调用登录失败的方法: fail(request,response,logname,backNews); } } else{ String backNews=\"请输入用户名和密码\"; fail(request,response,logname,backNews); } con.close(); } catch(SQLException exp){ String backNews=\"\"+exp; fail(request,response,logname,backNews); } } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ doPost(request,response); } public void success(HttpServletRequest request,HttpServletResponse response ,String logname,String password) { Login loginBean=null; HttpSession session=request.getSession(true); try{ loginBean=(Login)session.getAttribute(\"loginBean\"); if(loginBean==null){ loginBean=new Login(); //创建新的数据模型 session.setAttribute(\"loginBean\",loginBean); loginBean=(Login)session.getAttribute(\"loginBean\"); } String name =loginBean.getLogname(); if(name.equals(logname)) { loginBean.setBackNews(logname+\"已经登录了\"); loginBean.setLogname(logname); } else { //数据模型存储新的登录用户 loginBean.setBackNews(logname+\"登录成功\"); loginBean.setLogname(logname); } } catch(Exception ee){ loginBean=new Login(); session.setAttribute(\"loginBean\",loginBean); loginBean.setBackNews(logname+\"登录成功\"); loginBean.setLogname(logname); } } public void fail(HttpServletRequest request,HttpServletResponse response ,String logname,String backNews) { response.setContentType(\"text/html;charset=GB2312\"); try { PrintWriter out=response.getWriter(); out.println(\"\"); out.println(\"\"+logname+\"登录反馈结果\"+backNews+\"\") ; out.println(\"返回登录页面或主页\"); out.println(\"登录页面\"); out.println(\"\"); } catch(IOException exp){} } } 用户注册 用户登录 image.jpg MVC模式与数据库操作 ​ 本节的主要目的是学习使用MVC模式分页显示数据库表中的记录。 Javabean与Servlet管理 ​ 本节的Javabean类的包名均为mybean.data；Servlet类的包名均为myservlet.control。由于Servlet类中要使用Javabean，所以为了能顺利地编译Servlet类，不要忘记将Tomcat安装目录lib子目录中的servlet-api.jar文件复制到Tomcat服务器所使用的JDK的扩展目录中，比如，复制到D:\\jdk1.7\\jre\\lib\\ext中。然后，按下列步骤进行编译和保存有关的字节码文件 。 1．保存Javabean类和Servlet类的源文件 D:\\ mybean\\data 和 D:\\myservlet\\control 2．编译Javabean类 ​ D:> javac mybean\\data\\Javabean的源文件 3．编译Servlet类 ​ D:> javac myservlet\\control\\servlet的源文件 4．将类的字节码文件保存到服务器 ​ ch9\\WEB-INF\\classes\\mybean\\data 和 ​ ch9\\WEB-INF\\classes\\myservlet\\control 配置文件与数据库连接 本节的Servlet类的包名均为myservlet.control，需要配置Web服务目录的web.xml文件，即将下面的web.xml文件保存到Tomcat安装目录的Web服务目录ch9中。根据本书使用的Tomcat安装目录及Web服务目录，需要将web.xml文件保存到 D:\\apache-tomcat-8.0.3\\webapps\\ch9\\WEB-INF 目录中。 避免操作数据库出现中文乱码，连接中的代码是（用户是root，其密码是空）： String uri = \"jdbc:mysql://127.0.0.1/数据库名?\"+ \"user=root&password=&characterEncoding=gb2312\"; Connection con = DriverManager.getConnection(uri); ​ web.xml database myservlet.control.HandleDatabase database /helpReadRecord MVC设计细节 ​ 第7章曾使用bean读取数据库的记录（见7.6），该bean不仅要负责查询记录，而且要负责存储所查询到的记录。在MVC模式中，查询记录的任务由servlet对象负责，bean仅仅负责存储servlet对象所查询到的记录。 1．视图（JSP页面） choiceDatabase.jsp ，showRecord.jsp 2．模型（Javabean） ShowRecordByPage.java 3．控制器（servlet） HandleDatabase.java 数据库的名字: 表的名字: 每页显示记录数： 您查询的数据库：, 查询的表：。 记录分 页， 每页最多显示 条记录, 目前显示第 页。 package mybean.data; import com.sun.rowset.*; public class ShowRecordByPage{ CachedRowSetImpl rowSet=null; //存储表中全部记录的行集对象 int pageSize=10; //每页显示的记录数 int pageAllCount=0; //分页后的总页数 int showPage=1 ; //当前显示页 StringBuffer presentPageResult; //显示当前页内容 String databaseName=\"\"; //数据库名称 String tableName=\"\"; //表的名字 StringBuffer formTitle=null; //表头 public void setRowSet(CachedRowSetImpl set){ rowSet=set; } public CachedRowSetImpl getRowSet(){ return rowSet; } public void setPageSize(int size){ pageSize=size; } public int getPageSize(){ return pageSize; } public int getPageAllCount(){ return pageAllCount; } public void setPageAllCount(int n){ pageAllCount=n; } public void setShowPage(int n){ showPage=n; } public int getShowPage(){ return showPage; } public void setPresentPageResult(StringBuffer p){ presentPageResult=p; } public StringBuffer getPresentPageResult(){ return presentPageResult; } public void setDatabaseName(String s){ databaseName=s.trim(); } public String getDatabaseName(){ return databaseName; } public void setTableName(String s){ tableName=s.trim(); } public String getTableName(){ return tableName; } public void setFormTitle(StringBuffer s){ formTitle=s; } public StringBuffer getFormTitle(){ return formTitle; } } package myservlet.control; import mybean.data.ShowRecordByPage; import com.sun.rowset.*; import java.sql.*; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class HandleDatabase extends HttpServlet{ int 字段个数; CachedRowSetImpl rowSet=null; public void init(ServletConfig config) throws ServletException{ super.init(config); try { Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ Connection con; StringBuffer presentPageResult=new StringBuffer(); ShowRecordByPage databaseBean=null; HttpSession session=request.getSession(true); try{ databaseBean=(ShowRecordByPage)session.getAttribute(\"database\"); if(databaseBean==null){ databaseBean=new ShowRecordByPage(); //创建Javabean对象 session.setAttribute(\"database\",databaseBean); } } catch(Exception exp){ databaseBean=new ShowRecordByPage(); session.setAttribute(\"database\",databaseBean); } String databaseName=request.getParameter(\"databaseName\"); String tableName=request.getParameter(\"tableName\"); String ps=request.getParameter(\"pageSize\"); if(ps!=null){ try{ int mm=Integer.parseInt(ps); databaseBean.setPageSize(mm); } catch(NumberFormatException exp){ databaseBean.setPageSize(1); } } int showPage=databaseBean.getShowPage(); int pageSize=databaseBean.getPageSize(); boolean boo=databaseName!=null&&tableName!=null&& databaseName.length()>0&&tableName.length()>0; if(boo){ databaseBean.setDatabaseName(databaseName);//数据存储在databaseBean中 databaseBean.setTableName(tableName); //数据存储在databaseBean中 String uri=\"jdbc:mysql://127.0.0.1/\"+databaseName; try{ 字段个数=0; con=DriverManager.getConnection(uri,\"root\",\"\"); DatabaseMetaData metadata=con.getMetaData(); ResultSet rs1=metadata.getColumns(null,null,tableName,null); int k=0; String 字段[]=new String[100] ; while(rs1.next()){ 字段个数++; 字段[k]=rs1.getString(4); //获取字段的名字 k++; } StringBuffer str=new StringBuffer(); str.append(\"\"); for(int i=0;i\"+字段[i]+\"\"); str.append(\"\"); databaseBean.setFormTitle(str); //数据存储在databaseBean中 Statement sql= con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY); ResultSet rs=sql.executeQuery(\"SELECT * FROM \"+tableName); rowSet=new CachedRowSetImpl(); //创建行集对象 rowSet.populate(rs); con.close(); //关闭连接 databaseBean.setRowSet(rowSet); //数据存储在databaseBean中 rowSet.last(); int m=rowSet.getRow(); //总行数 int n=pageSize; int pageAllCount=((m%n)==0)?(m/n):(m/n+1); databaseBean.setPageAllCount(pageAllCount); } catch(SQLException exp){} } String whichPage=request.getParameter(\"whichPage\"); if(whichPage==null||whichPage.length()==0){ showPage=1; databaseBean.setShowPage(showPage); CachedRowSetImpl rowSet=databaseBean.getRowSet(); if(rowSet!=null){ presentPageResult=show(showPage,pageSize,rowSet); databaseBean.setPresentPageResult(presentPageResult); } } else if(whichPage.equals(\"nextPage\")){ showPage++; if(showPage>databaseBean.getPageAllCount()) showPage=1; databaseBean.setShowPage(showPage); CachedRowSetImpl rowSet=databaseBean.getRowSet(); if(rowSet!=null){ presentPageResult=show(showPage,pageSize,rowSet); databaseBean.setPresentPageResult(presentPageResult); } } else if(whichPage.equals(\"previousPage\")){ showPage--; if(showPage\"); for(int k=1;k\"+rowSet.getString(k)+\"\"); str.append(\"\"); rowSet.next(); } } catch(SQLException exp){} return str; } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ doPost(request,response); } } MVC模式与文件操作 ​ 在MVC模式中，读取文件的工作由servlet对象负责，bean仅仅负责存储servlet对象所读取的文件内容。 ​ 本节设计一个Web应用，在该Web应用中有两个JSP页面：choiceFile.jsp和showFile.jsp、一个Javabean和一个servlet。用户在JSP页面choiceFile.jsp选择一个文件，提交给servlet，该servlet负责读取文件的有关信息存放到JavaBean中，并请求JSP页面showFile.jsp显示Javanean中的数据。 ​ web.xml helpReadFile myservlet.control.HandleFile helpReadFile /helpReadFile 模型（Javabean） ​ 本节的Javabean类的包名为mybean.data。FileMessage.java模型中的getXXX和setXXX方法可以显示和修改模型中的数据，但不参与数据的处理。请读者比较本节中的FileMessage.java和7.5中ReadFile.java的不同之处。 ​ Javabean类的源文件FileMessage.java保存到：D:\\mybean\\data，如下列格式编译源文件，即带着包名形成的目录： D:> javac mybean\\data\\FileMessage.java ​ 将编译得到的字节码文件FileMessage.class复制到 ch9\\WEB-INF\\classes\\mybean\\data目录中。 package mybean.data; public class FileMessage { String filePath,fileName,fileContent; long fileLength; public void setFilePath(String str){ filePath=str; } public String getFilePath(){ return filePath; } public void setFileName(String str){ fileName=str; } public String getFileName(){ return fileName; } public void setFileContent(String str){ fileContent=str; } public String getFileContent(){ return fileContent; } public void setFileLength(long len){ fileLength=len; } public long getFileLength(){ return fileLength; } } 控制器（servlet） HandeFile .java 控制器是名字为helpReadFile的servlet对象（见web.xml中的配置），由下面的HandleFile类负责创建。由于Servlet类中要使用Javabean，所以为了能顺利地编译Servlet类，不要忘记将Tomcat安装目录lib子目录中的servlet-api.jar文件复制到Tomcat服务器所使用的JDK的扩展目录中，比如，复制到D:\\jdk1.7\\jre\\lib\\ext中。 Servlet类的包名为myservlet.control，将下面的Servlet类的源文件HandeFile.java保存到 D:\\myservlet\\control目录中，即保存时，让Servlet类的包名和Javabean类的包名形成的目录的父目录相同。用如下格式进行编译，即带着包名形成的目录： D:> javac myservlet\\control\\HandleFile.java 将编译得到的字节码文件HandeFile.class复制到 ch9\\WEB-INF\\classes\\myservlet\\control 目录中。 package myservlet.control; import mybean.data.FileMessage; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class HandleFile extends HttpServlet{ public void init(ServletConfig config) throws ServletException{ super.init(config); } public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ FileMessage file=new FileMessage(); //创建Javabean对象 request.setAttribute(\"file\",file); String filePath=request.getParameter(\"filePath\"); String fileName=request.getParameter(\"fileName\"); file.setFilePath(filePath); //将数据存储在file中 file.setFileName(fileName); try{ File f=new File(filePath,fileName); long length=f.length(); file.setFileLength(length); FileReader in=new FileReader(f) ; BufferedReader inTwo=new BufferedReader(in); StringBuffer stringbuffer=new StringBuffer(); String s=null; while ((s=inTwo.readLine())!=null) stringbuffer.append(\"\\n\"+s); String content=new String(stringbuffer); file.setFileContent(content); } catch(IOException exp){} RequestDispatcher dispatcher=request.getRequestDispatcher(\"showFile.jsp\"); dispatcher.forward(request, response); } public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ doPost(request,response); } } 视图（JSP页面） ​ choiceFile.jsp ​ 在choiceFile.jsp页面可以输入文件的路径和名字，并提交给名字为handleFile的servlet对象。servlet对象负责读取文件，并将读取的内容以及相关的数据存储到数据模型bean中，然后请求showFile.jsp页面显示模型中的数据 。 choiceFile.jsp （效果如图9.11） showFile .jsp（效果如图9.12） 输入文件的路径(如:d:/2000): 输入文件的名字(如:Hello.java): 文件的位置: , 文件的名字：, 文件的长度： 字节。 文件的内容： "}}